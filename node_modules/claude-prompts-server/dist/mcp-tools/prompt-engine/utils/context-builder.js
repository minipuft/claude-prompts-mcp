// @lifecycle canonical - Builds execution context for prompt engine.
/**
 * Context Builder - Handles execution context building
 *
 * Extracted from PromptExecutionService to provide focused
 * context building capabilities with clear separation of concerns.
 */
import { createLogger, getDefaultLoggerConfig } from '../../../logging/index.js';
const logger = createLogger(getDefaultLoggerConfig({
    logFile: '/tmp/context-builder.log',
    transport: 'stdio',
    enableDebug: false,
}));
/**
 * ContextBuilder handles all execution context building
 *
 * This class provides:
 * - Execution context creation and enhancement
 * - Framework integration and context injection
 * - Performance tracking and metadata collection
 * - Context validation and preparation
 */
export class ContextBuilder {
    constructor(frameworkManager, frameworkStateManager) {
        this.frameworkManager = frameworkManager;
        this.frameworkStateManager = frameworkStateManager;
    }
    /**
     * Build enhanced execution context
     */
    buildExecutionContext(promptId, promptArgs, convertedPrompt, options = {}) {
        try {
            logger.debug('üîß [ContextBuilder] Building execution context', {
                promptId,
                argsCount: Object.keys(promptArgs).length,
                hasFrameworkManager: !!this.frameworkManager,
            });
            const startTime = Date.now();
            const memoryUsage = this.getMemoryUsage();
            // Build base context - properly typed for execution parsers
            const baseExecutionContext = {
                conversationHistory: options['conversationHistory'],
                environmentVars: options['environmentVars'],
                promptDefaults: options['promptDefaults'],
                userSession: options['userSession'],
                systemContext: options['systemContext'],
            };
            // Build enhanced context
            const enhancedContext = {
                ...baseExecutionContext,
                promptId,
                promptArgs,
                sessionId: options['sessionId'] || this.generateSessionId(),
                forceRestart: options['forceRestart'] || false,
                enableGates: options['enableGates'] !== false,
                frameworkId: options['frameworkId'],
                contextData: options['contextData'] || {},
                metadata: this.buildMetadata(convertedPrompt, options),
                performance: {
                    startTime,
                    memoryUsage,
                },
            };
            // Add framework context if available
            if (this.frameworkManager && this.frameworkStateManager) {
                enhancedContext.frameworkContext = this.buildFrameworkContext(convertedPrompt, promptArgs, options);
            }
            logger.debug('‚úÖ [ContextBuilder] Execution context built successfully', {
                promptId,
                hasFrameworkContext: !!enhancedContext.frameworkContext,
                sessionId: enhancedContext.sessionId,
            });
            return enhancedContext;
        }
        catch (error) {
            logger.error('‚ùå [ContextBuilder] Context building failed', {
                promptId,
                error: error instanceof Error ? error.message : String(error),
            });
            // Return minimal context on error
            return {
                promptId,
                promptArgs,
                sessionId: this.generateSessionId(),
                forceRestart: false,
                enableGates: true,
                contextData: {},
                metadata: { error: error instanceof Error ? error.message : String(error) },
                performance: { startTime: Date.now() },
            };
        }
    }
    /**
     * Build framework-specific execution context
     */
    buildFrameworkContext(convertedPrompt, promptArgs, options) {
        try {
            if (!this.frameworkManager || !this.frameworkStateManager) {
                return undefined;
            }
            logger.debug('üéØ [ContextBuilder] Building framework context');
            const activeFramework = this.frameworkStateManager.getActiveFramework();
            const frameworkId = options['frameworkId'] || activeFramework;
            if (!frameworkId) {
                logger.debug('No framework specified, skipping framework context');
                return undefined;
            }
            const frameworkContext = this.frameworkManager.generateExecutionContext(convertedPrompt, {
                promptType: options['executionType'] || 'prompt',
                complexity: 'medium',
                userPreference: frameworkId,
            });
            logger.debug('‚úÖ [ContextBuilder] Framework context built', {
                frameworkId,
                hasSystemPrompt: !!frameworkContext.systemPrompt,
            });
            return frameworkContext;
        }
        catch (error) {
            logger.warn('‚ö†Ô∏è [ContextBuilder] Framework context building failed', {
                error: error instanceof Error ? error.message : String(error),
            });
            return undefined;
        }
    }
    /**
     * Build execution metadata
     */
    buildMetadata(convertedPrompt, options) {
        return {
            promptId: convertedPrompt.id,
            promptTitle: convertedPrompt.name,
            promptCategory: convertedPrompt.category,
            promptVersion: '1.0', // ConvertedPrompt doesn't have version property
            executionId: this.generateExecutionId(),
            timestamp: new Date().toISOString(),
            userAgent: options['userAgent'],
            clientInfo: options['clientInfo'],
            environment: process.env['NODE_ENV'] || 'development',
            nodeVersion: process.version,
            platform: process.platform,
        };
    }
    /**
     * Generate unique session ID
     */
    generateSessionId() {
        return `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    }
    /**
     * Generate unique execution ID
     */
    generateExecutionId() {
        return `exec_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    }
    /**
     * Get current memory usage
     */
    getMemoryUsage() {
        try {
            return process.memoryUsage().heapUsed;
        }
        catch (error) {
            logger.warn('‚ö†Ô∏è [ContextBuilder] Failed to get memory usage', {
                error: error instanceof Error ? error.message : String(error),
            });
            return 0;
        }
    }
    /**
     * Validate execution context
     */
    validateContext(context) {
        const errors = [];
        const warnings = [];
        try {
            // Required fields validation
            if (!context.promptId) {
                errors.push('Prompt ID is required');
            }
            if (!context.sessionId) {
                errors.push('Session ID is required');
            }
            if (!context.promptArgs) {
                warnings.push('No prompt arguments provided');
            }
            // Context data validation
            if (context.contextData && typeof context.contextData !== 'object') {
                errors.push('Context data must be an object');
            }
            // Performance data validation
            if (context.performance && !context.performance.startTime) {
                warnings.push('Performance tracking missing start time');
            }
            // Framework context validation
            if (context.frameworkContext) {
                if (!context.frameworkContext.selectedFramework) {
                    warnings.push('Framework context missing selected framework');
                }
            }
            const isValid = errors.length === 0;
            logger.debug('üîç [ContextBuilder] Context validation completed', {
                isValid,
                errorsCount: errors.length,
                warningsCount: warnings.length,
            });
            return { isValid, errors, warnings };
        }
        catch (error) {
            logger.error('‚ùå [ContextBuilder] Context validation failed', {
                error: error instanceof Error ? error.message : String(error),
            });
            return {
                isValid: false,
                errors: [`Validation error: ${error instanceof Error ? error.message : String(error)}`],
                warnings,
            };
        }
    }
    /**
     * Clone context for reuse
     */
    cloneContext(context, overrides = {}) {
        try {
            const clonedContext = {
                ...context,
                ...overrides,
                promptArgs: { ...context.promptArgs, ...(overrides.promptArgs || {}) },
                contextData: { ...context.contextData, ...(overrides.contextData || {}) },
                metadata: { ...context.metadata, ...(overrides.metadata || {}) },
                performance: {
                    startTime: context.performance?.startTime || Date.now(),
                    memoryUsage: context.performance?.memoryUsage,
                    ...(overrides.performance || {}),
                },
            };
            // Update execution tracking
            if (clonedContext.metadata) {
                clonedContext.metadata['clonedFrom'] = context.metadata?.['executionId'];
                clonedContext.metadata['executionId'] = this.generateExecutionId();
            }
            logger.debug('üîÑ [ContextBuilder] Context cloned successfully', {
                originalId: context.metadata?.['executionId'],
                clonedId: clonedContext.metadata?.['executionId'],
            });
            return clonedContext;
        }
        catch (error) {
            logger.error('‚ùå [ContextBuilder] Context cloning failed', {
                error: error instanceof Error ? error.message : String(error),
            });
            throw error;
        }
    }
}
//# sourceMappingURL=context-builder.js.map