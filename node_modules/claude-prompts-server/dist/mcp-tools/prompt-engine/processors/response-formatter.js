// @lifecycle canonical - Formats prompt execution responses.
/**
 * Response Formatter - Handles response formatting and coordination
 *
 * Extracted from PromptExecutionService to provide focused
 * response formatting capabilities with clear separation of concerns.
 */
const fallbackLogger = {
    info: () => { },
    debug: () => { },
    warn: (...args) => console.warn('[ResponseFormatter]', ...args),
    error: (...args) => console.error('[ResponseFormatter]', ...args),
};
/**
 * ResponseFormatter handles all response-related formatting and coordination
 *
 * This class provides:
 * - Response formatting for different execution types
 * - Error response handling and formatting
 * - Analytics integration and tracking
 * - Structured response building
 */
function normalizeToolResponse(payload, defaultIsError = false) {
    if (payload && typeof payload === 'object') {
        if (Array.isArray(payload.content)) {
            const normalized = {
                content: payload.content,
                isError: payload.isError ?? defaultIsError,
            };
            if (payload.structuredContent !== undefined) {
                normalized.structuredContent = payload.structuredContent;
            }
            if (payload.metadata !== undefined) {
                normalized.metadata = payload.metadata;
            }
            return normalized;
        }
        if (typeof payload.content === 'string') {
            return {
                content: [{ type: 'text', text: payload.content }],
                isError: payload.isError ?? defaultIsError,
                structuredContent: payload.structuredContent,
            };
        }
        if (typeof payload.text === 'string') {
            return {
                content: [{ type: 'text', text: payload.text }],
                isError: payload.isError ?? defaultIsError,
                structuredContent: payload.structuredContent,
            };
        }
        if (typeof payload.message === 'string') {
            return {
                content: [{ type: 'text', text: payload.message }],
                isError: payload.isError ?? defaultIsError,
                structuredContent: payload.structuredContent,
            };
        }
    }
    const text = typeof payload === 'string' ? payload : JSON.stringify(payload, null, 2);
    return {
        content: [{ type: 'text', text }],
        isError: defaultIsError,
    };
}
export class ResponseFormatter {
    constructor(logger = fallbackLogger) {
        this.logger = logger;
    }
    /**
     * Set analytics service for tracking
     */
    setAnalyticsService(service) {
        this.analyticsService = service;
        this.logger.debug('üìä [ResponseFormatter] Analytics service set');
    }
    /**
     * Format general response content
     */
    formatResponse(content) {
        try {
            this.logger.debug('üîß [ResponseFormatter] Formatting general response');
            return normalizeToolResponse(content, false);
        }
        catch (error) {
            this.logger.error('‚ùå [ResponseFormatter] General response formatting failed', {
                error: error instanceof Error ? error.message : String(error),
            });
            return normalizeToolResponse(content, false);
        }
    }
    /**
     * Format prompt engine response with execution context
     */
    formatPromptEngineResponse(response, executionContext = {
        executionId: `exec_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`,
        executionType: 'single',
        startTime: Date.now(),
        endTime: Date.now(),
        frameworkEnabled: false,
        success: true,
    }, options = {}, gateResults) {
        // IMPORTANT: keep the rendered template text inside `content`. Structured metadata is
        // optional and should never replace the main instructions, otherwise the LLM will only
        // see bookkeeping data. Only add structured blocks when a chain execution explicitly
        // needs them.
        try {
            this.logger.debug('üéØ [ResponseFormatter] Formatting prompt engine response', {
                executionType: executionContext?.executionType,
                frameworkUsed: executionContext?.frameworkUsed,
                stepsExecuted: executionContext?.stepsExecuted,
            });
            // Track analytics if service is available
            if (this.analyticsService && executionContext) {
                this.trackExecution(executionContext);
            }
            if (response &&
                typeof response === 'object' &&
                Array.isArray(response.content)) {
                return response;
            }
            const toolResponse = normalizeToolResponse(response, false);
            // Only include structuredContent for chains (step tracking metadata)
            // Prompts and templates should return clean content without metadata clutter
            const includeStructuredContent = executionContext.executionType === 'chain' && options?.includeStructuredContent !== false;
            if (includeStructuredContent) {
                const executionDuration = executionContext.endTime - executionContext.startTime;
                const structuredContent = {
                    execution: {
                        id: executionContext.executionId,
                        type: executionContext.executionType,
                        duration_ms: executionDuration,
                        framework: executionContext.frameworkUsed ?? null,
                        steps: executionContext.stepsExecuted ?? null,
                    },
                };
                if (executionContext.chainId) {
                    structuredContent.chain = {
                        id: executionContext.chainId,
                        status: executionContext.chainProgress?.status ?? 'in_progress',
                        current_step: executionContext.chainProgress?.currentStep ?? null,
                        total_steps: executionContext.chainProgress?.totalSteps ?? null,
                    };
                }
                if (gateResults) {
                    structuredContent.gates = {
                        enabled: true,
                        passed: gateResults.passed,
                        total: gateResults.gateResults?.length ?? 0,
                        failed: gateResults.gateResults?.filter((g) => !g.passed) ?? [],
                        execution_ms: gateResults.executionTime ?? 0,
                        retries: gateResults.retryRequired ? 1 : 0,
                    };
                }
                toolResponse.structuredContent = structuredContent;
            }
            if (options?.includeMetadata || options?.metadata) {
                const defaultMetadata = {
                    executionType: executionContext.executionType,
                    frameworkUsed: executionContext.frameworkUsed,
                };
                if (executionContext.chainId) {
                    defaultMetadata.chainId = executionContext.chainId;
                }
                if (executionContext.chainProgress) {
                    if (typeof executionContext.chainProgress.currentStep === 'number') {
                        defaultMetadata.currentStep = executionContext.chainProgress.currentStep;
                    }
                    if (typeof executionContext.chainProgress.totalSteps === 'number') {
                        defaultMetadata.totalSteps = executionContext.chainProgress.totalSteps;
                    }
                }
                toolResponse.metadata = {
                    ...defaultMetadata,
                    ...(options?.metadata ?? {}),
                };
            }
            this.logger.debug('‚úÖ [ResponseFormatter] Prompt engine response formatted successfully');
            return toolResponse;
        }
        catch (error) {
            this.logger.error('‚ùå [ResponseFormatter] Prompt engine response formatting failed', {
                error: error instanceof Error ? error.message : String(error),
            });
            // Return error response
            return this.formatErrorResponse(error, executionContext, options);
        }
    }
    /**
     * Format error response
     */
    formatErrorResponse(error, executionContext, _options) {
        try {
            this.logger.debug('üö® [ResponseFormatter] Formatting error response', {
                errorType: error instanceof Error ? error.constructor.name : typeof error,
            });
            // Track error analytics if service is available
            if (this.analyticsService && executionContext) {
                this.trackError(error, executionContext);
            }
            const errorMessage = error instanceof Error ? error.message : String(error);
            const toolResponse = normalizeToolResponse(`Error: ${errorMessage}`, true);
            if (executionContext?.executionType === 'chain') {
                const executionDuration = executionContext.endTime - executionContext.startTime;
                toolResponse.structuredContent = {
                    execution: {
                        id: executionContext.executionId,
                        type: executionContext.executionType,
                        duration_ms: executionDuration,
                        framework: executionContext.frameworkUsed ?? null,
                        steps: executionContext.stepsExecuted ?? null,
                    },
                    chain: executionContext.chainId
                        ? {
                            id: executionContext.chainId,
                            status: executionContext.chainProgress?.status ?? 'in_progress',
                            current_step: executionContext.chainProgress?.currentStep ?? null,
                            total_steps: executionContext.chainProgress?.totalSteps ?? null,
                        }
                        : undefined,
                };
            }
            this.logger.debug('‚úÖ [ResponseFormatter] Error response formatted successfully');
            return toolResponse;
        }
        catch (formattingError) {
            this.logger.error('‚ùå [ResponseFormatter] Error response formatting failed', {
                originalError: error instanceof Error ? error.message : String(error),
                formattingError: formattingError instanceof Error ? formattingError.message : String(formattingError),
            });
            // Fallback to minimal response
            return normalizeToolResponse(`Error: ${error instanceof Error ? error.message : String(error)}`, true);
        }
    }
    /**
     * Format chain execution response
     */
    formatChainResponse(response, chainId, currentStep, totalSteps, executionContext) {
        try {
            this.logger.debug('üîó [ResponseFormatter] Formatting chain response', {
                chainId,
                currentStep,
                totalSteps,
                executionType: executionContext?.executionType,
            });
            const toolResponse = normalizeToolResponse(response, false);
            this.logger.debug('‚úÖ [ResponseFormatter] Chain response formatted successfully');
            return toolResponse;
        }
        catch (error) {
            this.logger.error('‚ùå [ResponseFormatter] Chain response formatting failed', {
                chainId,
                error: error instanceof Error ? error.message : String(error),
            });
            return this.formatErrorResponse(error, executionContext);
        }
    }
    /**
     * Track execution for analytics
     */
    trackExecution(executionContext) {
        try {
            if (this.analyticsService?.trackExecution) {
                this.analyticsService.trackExecution({
                    executionId: executionContext.executionId,
                    executionType: executionContext.executionType,
                    duration: executionContext.endTime - executionContext.startTime,
                    frameworkUsed: executionContext.frameworkUsed,
                    stepsExecuted: executionContext.stepsExecuted,
                    success: executionContext.success,
                    sessionId: executionContext.sessionId,
                });
            }
        }
        catch (error) {
            this.logger.warn('‚ö†Ô∏è [ResponseFormatter] Analytics tracking failed', {
                error: error instanceof Error ? error.message : String(error),
            });
        }
    }
    /**
     * Track error for analytics
     */
    trackError(error, executionContext) {
        try {
            if (this.analyticsService?.trackError) {
                this.analyticsService.trackError({
                    executionId: executionContext.executionId,
                    executionType: executionContext.executionType,
                    errorType: error instanceof Error ? error.constructor.name : 'Unknown',
                    errorMessage: error instanceof Error ? error.message : String(error),
                    sessionId: executionContext.sessionId,
                });
            }
        }
        catch (trackingError) {
            this.logger.warn('‚ö†Ô∏è [ResponseFormatter] Error analytics tracking failed', {
                error: trackingError instanceof Error ? trackingError.message : String(trackingError),
            });
        }
    }
}
//# sourceMappingURL=response-formatter.js.map