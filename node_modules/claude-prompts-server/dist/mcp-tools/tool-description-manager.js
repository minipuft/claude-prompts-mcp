// @lifecycle canonical - Manages MCP tool descriptions and discovery metadata.
/**
 * Tool Description Manager
 *
 * Manages externalized tool descriptions with graceful fallback to defaults.
 * Methodology-specific overlays are sourced solely from runtime YAML definitions (SOT); config
 * may define baseline/non-methodology text but methodology entries are ignored (warned).
 * Follows established ConfigManager pattern for consistency with existing architecture.
 */
import { EventEmitter } from 'events';
import { watch } from 'node:fs';
import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import { getDefaultRuntimeLoader, createGenericGuide, } from '../frameworks/methodology/index.js';
const DEFAULT_TOOL_DESCRIPTION_ENTRIES = [
    [
        'prompt_engine',
        {
            description: 'üöÄ PROMPT ENGINE: Executes prompts/chains with % modifiers and unified gates. Start with real prompt ids (no invented labels); list/inspect via prompt_manager(action:"list") when unsure. Inline gates via `::`; frameworks via `@`; `%clean`/`%lean` disable framework injection. Use `>>guide <topic>` only when you need help.',
            shortDescription: 'Execute prompts and chains',
            category: 'execution',
        },
    ],
    [
        'prompt_manager',
        {
            description: 'üìù PROMPT MANAGER: Lifecycle operations for prompts. Actions: create|update|delete|list|inspect|analyze_type|analyze_gates|guide. Use `guide` action to discover which verb fits your goal.',
            shortDescription: 'Manage prompt lifecycle',
            category: 'management',
        },
    ],
    [
        'system_control',
        {
            description: '‚öôÔ∏è SYSTEM CONTROL: Framework switching, gate management, analytics. Actions: status|framework|gates|analytics|config|maintenance|guide. Use `>>help` for system-wide guidance.',
            shortDescription: 'Framework, gates, analytics controls',
            category: 'system',
        },
    ],
];
function cloneToolDescription(description) {
    return {
        ...description,
        parameters: description.parameters ? { ...description.parameters } : undefined,
        frameworkAware: description.frameworkAware
            ? {
                ...description.frameworkAware,
                methodologies: description.frameworkAware.methodologies
                    ? { ...description.frameworkAware.methodologies }
                    : undefined,
                parametersEnabled: description.frameworkAware.parametersEnabled
                    ? { ...description.frameworkAware.parametersEnabled }
                    : undefined,
                parametersDisabled: description.frameworkAware.parametersDisabled
                    ? { ...description.frameworkAware.parametersDisabled }
                    : undefined,
                methodologyParameters: description.frameworkAware.methodologyParameters
                    ? { ...description.frameworkAware.methodologyParameters }
                    : undefined,
            }
            : undefined,
    };
}
function createDefaultToolDescriptionMap() {
    return new Map(DEFAULT_TOOL_DESCRIPTION_ENTRIES.map(([name, description]) => [
        name,
        cloneToolDescription(description),
    ]));
}
export function getDefaultToolDescription(toolName) {
    const entry = DEFAULT_TOOL_DESCRIPTION_ENTRIES.find(([name]) => name === toolName);
    return entry ? cloneToolDescription(entry[1]) : undefined;
}
/**
 * Manages tool descriptions loaded from external configuration with hot-reload support
 */
export class ToolDescriptionManager extends EventEmitter {
    constructor(logger, configManager) {
        super();
        this.isInitialized = false;
        this.isWatching = false;
        this.lastLoadSource = 'defaults';
        this.logger = logger;
        this.configManager = configManager;
        const serverRoot = configManager.getServerRoot();
        // Generated from contracts - single source of truth
        this.configPath = path.join(serverRoot, 'src', 'tooling', 'contracts', '_generated', 'tool-descriptions.json');
        this.activeConfigPath = this.configPath;
        this.fallbackConfigPath = this.configPath; // No separate fallback - contracts are SSOT
        this.legacyFallbackPath = this.configPath;
        this.descriptions = new Map();
        this.defaults = this.createDefaults();
        this.methodologyDescriptions = new Map();
        this.frameworksConfig = this.configManager.getFrameworksConfig();
        this.frameworksConfigListener = (newConfig) => {
            this.frameworksConfig = { ...newConfig };
            this.logger.info(`Tool description manager feature toggle updated (dynamicDescriptions: ${this.frameworksConfig.enableDynamicToolDescriptions})`);
            if (this.isInitialized) {
                void this.synchronizeActiveConfig('Framework feature config changed (dynamic tool descriptions toggle)');
            }
        };
        this.configManager.on('frameworksConfigChanged', this.frameworksConfigListener);
    }
    /**
     * Normalize methodology keys for consistent lookup (case-insensitive)
     */
    normalizeMethodologyKey(methodology) {
        if (!methodology)
            return undefined;
        return methodology.trim().toUpperCase();
    }
    /**
     * Create default descriptions as fallback
     */
    createDefaults() {
        return createDefaultToolDescriptionMap();
    }
    /**
     * Warn if config attempts to define methodology-specific overlays (YAML is SOT for methodology).
     */
    warnOnMethodologyConfigLeak(toolName, description) {
        const hasMethodologyDesc = Boolean(description.frameworkAware?.methodologies);
        const hasMethodologyParams = Boolean(description.frameworkAware?.methodologyParameters);
        if (hasMethodologyDesc || hasMethodologyParams) {
            this.logger.warn(`[ToolDescriptionManager] Config contains methodology-specific entries for ${toolName}; YAML overlays are the sole source of truth. Config methodology entries are ignored.`);
        }
    }
    /**
     * Pre-load all methodology descriptions for dynamic switching
     * Uses RuntimeMethodologyLoader for YAML-based methodology loading
     */
    preloadMethodologyDescriptions() {
        try {
            this.methodologyDescriptions.clear();
            const loader = getDefaultRuntimeLoader();
            const methodologyIds = loader.discoverMethodologies();
            for (const id of methodologyIds) {
                const definition = loader.loadMethodology(id);
                if (!definition)
                    continue;
                const guide = createGenericGuide(definition);
                const descriptions = guide.getToolDescriptions?.() || {};
                const methodologyKey = this.normalizeMethodologyKey(guide.methodology);
                const frameworkKey = this.normalizeMethodologyKey(guide.frameworkId);
                if (methodologyKey) {
                    this.methodologyDescriptions.set(methodologyKey, descriptions);
                }
                if (frameworkKey) {
                    this.methodologyDescriptions.set(frameworkKey, descriptions);
                }
            }
            this.logger.info(`‚úÖ Pre-loaded tool descriptions for ${this.methodologyDescriptions.size} methodologies from YAML (SOT)`);
        }
        catch (error) {
            this.logger.error(`Failed to pre-load methodology descriptions: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async readToolDescriptionsConfig(filePath) {
        try {
            const content = await fs.readFile(filePath, 'utf-8');
            const config = JSON.parse(content);
            if (!config.tools || typeof config.tools !== 'object') {
                throw new Error('Invalid tool descriptions config: missing or invalid tools section');
            }
            return config;
        }
        catch (error) {
            if (error?.code !== 'ENOENT') {
                this.logger.warn(`[ToolDescriptionManager] Unable to read tool descriptions from ${filePath}: ${error instanceof Error ? error.message : String(error)}`);
            }
            return undefined;
        }
    }
    createConfigFromMap(sourceMap, source) {
        return {
            version: '2.0.0',
            lastUpdated: new Date().toISOString(),
            generatedFrom: source,
            tools: Object.fromEntries(Array.from(sourceMap.entries()).map(([name, description]) => [
                name,
                cloneToolDescription(description),
            ])),
        };
    }
    async loadBaseConfig() {
        // Load from generated tool-descriptions.json (contracts are SSOT)
        const generated = await this.readToolDescriptionsConfig(this.configPath);
        if (generated) {
            return { config: generated, source: 'active', path: this.configPath };
        }
        // Fallback to in-memory defaults if generated file missing
        // This should only happen if contracts weren't generated - run `npm run generate:contracts`
        this.logger.warn(`[ToolDescriptionManager] Generated tool-descriptions.json not found at ${this.configPath}. ` +
            `Run 'npm run generate:contracts' to generate from contracts. Using in-memory defaults.`);
        return {
            config: this.createConfigFromMap(this.defaults, 'defaults'),
            source: 'defaults',
            path: '<defaults>',
        };
    }
    setDescriptionsFromConfig(config) {
        this.descriptions.clear();
        for (const [name, description] of Object.entries(config.tools)) {
            this.warnOnMethodologyConfigLeak(name, description);
            this.descriptions.set(name, cloneToolDescription(description));
        }
    }
    getActiveFrameworkContext() {
        if (!this.frameworkStateManager) {
            return {};
        }
        try {
            const state = this.frameworkStateManager.getCurrentState();
            const activeFramework = this.frameworkStateManager.getActiveFramework();
            return {
                activeFramework: activeFramework?.id,
                activeMethodology: activeFramework?.methodology ?? activeFramework?.id,
                frameworkSystemEnabled: state?.frameworkSystemEnabled,
            };
        }
        catch (error) {
            this.logger.warn(`[ToolDescriptionManager] Unable to read framework state for tool descriptions: ${error instanceof Error ? error.message : String(error)}`);
            return {};
        }
    }
    buildActiveConfig(baseConfig, activeContext) {
        const methodologyKey = this.normalizeMethodologyKey(activeContext.activeMethodology ?? activeContext.activeFramework);
        const dynamicDescriptionsEnabled = this.frameworksConfig.enableDynamicToolDescriptions &&
            (activeContext.frameworkSystemEnabled ?? true);
        const tools = {};
        for (const [name, description] of Object.entries(baseConfig.tools)) {
            const baseDescription = cloneToolDescription(description);
            if (dynamicDescriptionsEnabled && methodologyKey) {
                const methodologyDescs = this.methodologyDescriptions.get(methodologyKey);
                const methodologyTool = methodologyDescs?.[name] || undefined;
                if (methodologyTool?.description) {
                    baseDescription.description = methodologyTool.description;
                }
                if (methodologyTool?.parameters) {
                    baseDescription.parameters = {
                        ...baseDescription.parameters,
                        ...methodologyTool.parameters,
                    };
                }
            }
            tools[name] = baseDescription;
        }
        return {
            ...baseConfig,
            tools,
            activeFramework: activeContext.activeFramework,
            activeMethodology: activeContext.activeMethodology,
            generatedAt: new Date().toISOString(),
            generatedFrom: baseConfig.generatedFrom ?? 'fallback',
        };
    }
    async maybePersistActiveConfig(config) {
        try {
            const serialized = JSON.stringify(config, null, 2);
            let existing;
            try {
                existing = await fs.readFile(this.activeConfigPath, 'utf-8');
            }
            catch (error) {
                if (error?.code !== 'ENOENT') {
                    this.logger.warn(`[ToolDescriptionManager] Unable to read active tool descriptions before write: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            if (existing && existing.trim() === serialized.trim()) {
                return false;
            }
            await fs.mkdir(path.dirname(this.activeConfigPath), { recursive: true });
            await fs.writeFile(this.activeConfigPath, serialized, 'utf-8');
            this.logger.info(`üíæ Wrote active tool descriptions to ${this.activeConfigPath} (framework: ${config.activeFramework || 'n/a'}, methodology: ${config.activeMethodology || 'n/a'})`);
            return true;
        }
        catch (error) {
            this.logger.warn(`[ToolDescriptionManager] Failed to persist active tool descriptions: ${error instanceof Error ? error.message : String(error)}`);
            return false;
        }
    }
    async synchronizeActiveConfig(reason, options) {
        try {
            const base = await this.loadBaseConfig();
            this.lastLoadSource = base.source;
            this.preloadMethodologyDescriptions();
            const activeContext = this.getActiveFrameworkContext();
            const activeConfig = this.buildActiveConfig(base.config, activeContext);
            activeConfig.generatedFrom = base.source;
            await this.maybePersistActiveConfig(activeConfig);
            this.setDescriptionsFromConfig(activeConfig);
            this.isInitialized = true;
            this.logger.info(`‚úÖ Synchronized tool descriptions (${reason}); source=${base.source}, framework=${activeContext.activeFramework || 'n/a'}, methodology=${activeContext.activeMethodology || 'n/a'}`);
            if (options?.emitChange ?? true) {
                this.emit('descriptions-changed', this.getStats());
            }
        }
        catch (error) {
            this.logger.error(`[ToolDescriptionManager] Failed to synchronize tool descriptions: ${error instanceof Error ? error.message : String(error)}`);
            this.descriptions = new Map(this.defaults);
            this.lastLoadSource = 'defaults';
            this.isInitialized = true;
            if (options?.emitChange ?? true) {
                this.emit('descriptions-error', error);
            }
        }
    }
    setFrameworkStateManager(frameworkStateManager) {
        if (this.frameworkStateManager === frameworkStateManager) {
            return;
        }
        // Clean up old listeners if re-binding
        if (this.frameworkStateManager && this.frameworkSwitchedListener) {
            this.frameworkStateManager.off('framework-switched', this.frameworkSwitchedListener);
        }
        if (this.frameworkStateManager && this.frameworkToggledListener) {
            this.frameworkStateManager.off('framework-system-toggled', this.frameworkToggledListener);
        }
        this.frameworkStateManager = frameworkStateManager;
        this.frameworkSwitchedListener = async (_prev, _next, reason) => {
            await this.synchronizeActiveConfig(`framework switched: ${reason}`);
        };
        this.frameworkToggledListener = async (enabled, reason) => {
            await this.synchronizeActiveConfig(`framework system ${enabled ? 'enabled' : 'disabled'}: ${reason}`);
        };
        this.frameworkStateManager.on('framework-switched', this.frameworkSwitchedListener);
        this.frameworkStateManager.on('framework-system-toggled', this.frameworkToggledListener);
    }
    /**
     * Initialize by loading descriptions from external config file
     */
    async initialize() {
        await this.synchronizeActiveConfig('initial load', { emitChange: false });
    }
    /**
     * Get description for a specific tool with corrected priority hierarchy
     */
    getDescription(toolName, frameworkEnabled, activeMethodology, options) {
        const toolDesc = this.descriptions.get(toolName) || this.defaults.get(toolName);
        if (!toolDesc) {
            this.logger.warn(`No description found for tool: ${toolName}`);
            return `Tool: ${toolName}`;
        }
        if (!this.frameworksConfig.enableDynamicToolDescriptions) {
            this.logger.debug(`Dynamic tool descriptions disabled; using base description for ${toolName}`);
            return toolDesc.description;
        }
        const applyMethodologyOverride = options?.applyMethodologyOverride ?? true;
        this.logger.debug(`Getting description for ${toolName} (framework: ${frameworkEnabled}, methodology: ${activeMethodology})`);
        const methodologyKey = this.normalizeMethodologyKey(activeMethodology);
        const methodologyLogName = activeMethodology ?? methodologyKey;
        // PRIORITY 1: Methodology-specific descriptions from YAML guides (SOT, HIGHEST PRIORITY)
        if (applyMethodologyOverride && methodologyKey) {
            const methodologyDescs = this.methodologyDescriptions.get(methodologyKey);
            if (methodologyDescs?.[toolName]?.description) {
                const methodologyDesc = methodologyDescs[toolName].description;
                this.logger.debug(`‚úÖ Using methodology-specific description from ${methodologyLogName} guide for ${toolName}`);
                return methodologyDesc;
            }
            this.logger.debug(`‚ö†Ô∏è No methodology-specific description found for ${toolName} in ${methodologyLogName} guide`);
        }
        // PRIORITY 2: Framework-aware descriptions from config (if methodology desc not available)
        if (frameworkEnabled !== undefined && toolDesc.frameworkAware) {
            if (frameworkEnabled && toolDesc.frameworkAware.enabled) {
                this.logger.debug(`‚úÖ Using framework-aware enabled description from config for ${toolName}`);
                return toolDesc.frameworkAware.enabled;
            }
            else if (!frameworkEnabled && toolDesc.frameworkAware.disabled) {
                this.logger.debug(`‚úÖ Using framework-aware disabled description from config for ${toolName}`);
                return toolDesc.frameworkAware.disabled;
            }
        }
        // PRIORITY 3: Basic config file descriptions (LOWER PRIORITY)
        this.logger.debug(`‚úÖ Using basic config/default description for ${toolName}`);
        return toolDesc.description;
    }
    /**
     * Get parameter description for a specific tool parameter
     */
    getParameterDescription(toolName, paramName, frameworkEnabled, activeMethodology, options) {
        const toolDesc = this.descriptions.get(toolName) || this.defaults.get(toolName);
        if (!toolDesc) {
            return undefined;
        }
        if (!this.frameworksConfig.enableDynamicToolDescriptions) {
            const param = toolDesc.parameters?.[paramName];
            return typeof param === 'string' ? param : param?.description;
        }
        const applyMethodologyOverride = options?.applyMethodologyOverride ?? true;
        if (!toolDesc.parameters)
            return undefined;
        const methodologyKey = this.normalizeMethodologyKey(activeMethodology);
        // Check for methodology-specific parameter descriptions first (from YAML SOT cache)
        if (applyMethodologyOverride && methodologyKey) {
            const methodologyDescs = this.methodologyDescriptions.get(methodologyKey);
            const methodologyTool = methodologyDescs?.[toolName];
            if (methodologyTool?.parameters?.[paramName]) {
                const param = methodologyTool.parameters[paramName];
                return typeof param === 'string' ? param : param?.description;
            }
        }
        // Check for framework-aware parameter descriptions
        if (frameworkEnabled !== undefined && toolDesc.frameworkAware) {
            const frameworkParams = frameworkEnabled
                ? toolDesc.frameworkAware.parametersEnabled
                : toolDesc.frameworkAware.parametersDisabled;
            if (frameworkParams?.[paramName]) {
                const param = frameworkParams[paramName];
                return typeof param === 'string' ? param : param?.description;
            }
        }
        // Fall back to default parameters
        const param = toolDesc.parameters[paramName];
        return typeof param === 'string' ? param : param?.description;
    }
    /**
     * Get all available tool names
     */
    getAvailableTools() {
        return Array.from(this.descriptions.keys());
    }
    /**
     * Check if manager is properly initialized
     */
    isReady() {
        return this.isInitialized;
    }
    /**
     * Get configuration path for debugging
     */
    getConfigPath() {
        return this.activeConfigPath;
    }
    /**
     * Get statistics about loaded descriptions
     */
    getStats() {
        const loadedFromFile = this.lastLoadSource === 'defaults' ? 0 : this.descriptions.size || 0;
        const defaultCount = this.defaults.size;
        const usingDefaults = this.lastLoadSource === 'defaults' ? defaultCount : 0;
        return {
            totalDescriptions: this.descriptions.size,
            loadedFromFile,
            usingDefaults,
            configPath: this.activeConfigPath,
            isInitialized: this.isInitialized,
            source: this.lastLoadSource,
        };
    }
    /**
     * Start watching the tool descriptions file for changes
     */
    startWatching() {
        if (this.isWatching) {
            this.logger.debug('Tool description file watcher already active');
            return;
        }
        try {
            this.logger.info(`üîç Starting file watcher for tool descriptions: ${this.activeConfigPath}`);
            this.fileWatcher = watch(this.activeConfigPath, (eventType) => {
                if (eventType === 'change') {
                    this.handleFileChange();
                }
            });
            this.fileWatcher.on('error', (error) => {
                this.logger.error(`Tool description file watcher error: ${error.message}`);
                this.isWatching = false;
            });
            this.isWatching = true;
            this.logger.info('‚úÖ Tool description hot-reload watcher started successfully');
        }
        catch (error) {
            this.logger.error(`Failed to start tool description file watcher: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Stop watching the tool descriptions file
     */
    stopWatching() {
        if (this.fileWatcher) {
            this.logger.info('üõë Stopping tool description file watcher...');
            this.fileWatcher.close();
            this.fileWatcher = undefined;
        }
        if (this.reloadDebounceTimer) {
            clearTimeout(this.reloadDebounceTimer);
            this.reloadDebounceTimer = undefined;
        }
        this.isWatching = false;
        this.logger.info('‚úÖ Tool description file watcher stopped');
    }
    /**
     * Handle file change event with debouncing
     */
    handleFileChange() {
        // Clear existing timer to debounce rapid file changes
        if (this.reloadDebounceTimer) {
            clearTimeout(this.reloadDebounceTimer);
        }
        // Debounce file changes (wait 500ms after last change)
        this.reloadDebounceTimer = setTimeout(async () => {
            try {
                this.logger.info('üìù Tool descriptions file changed, reloading...');
                await this.reload();
                this.emit('descriptions-changed', this.getStats());
                this.logger.info('‚úÖ Tool descriptions reloaded successfully');
            }
            catch (error) {
                this.logger.error(`Failed to reload tool descriptions: ${error instanceof Error ? error.message : String(error)}`);
                this.emit('descriptions-error', error);
            }
        }, 500);
    }
    /**
     * Reload descriptions from file
     */
    async reload() {
        await this.synchronizeActiveConfig('file change');
    }
    /**
     * Check if file watching is active
     */
    isWatchingFile() {
        return this.isWatching;
    }
    /**
     * Cleanup resources on shutdown
     */
    shutdown() {
        this.stopWatching();
        if (this.frameworksConfigListener) {
            this.configManager.off('frameworksConfigChanged', this.frameworksConfigListener);
        }
        if (this.frameworkStateManager && this.frameworkSwitchedListener) {
            this.frameworkStateManager.off('framework-switched', this.frameworkSwitchedListener);
        }
        if (this.frameworkStateManager && this.frameworkToggledListener) {
            this.frameworkStateManager.off('framework-system-toggled', this.frameworkToggledListener);
        }
        this.removeAllListeners();
    }
}
/**
 * Factory function following established pattern
 */
export function createToolDescriptionManager(logger, configManager) {
    return new ToolDescriptionManager(logger, configManager);
}
//# sourceMappingURL=tool-description-manager.js.map