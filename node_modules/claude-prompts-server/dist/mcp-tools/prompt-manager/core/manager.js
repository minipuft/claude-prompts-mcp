// @lifecycle canonical - Main prompt manager implementation for MCP.
/**
 * Consolidated Prompt Manager - Modular Architecture Orchestration Layer
 *
 * This class maintains 100% backwards compatibility with the original API
 * while delegating operations to specialized modules for improved maintainability.
 */
import { promptManagerMetadata } from '../../../tooling/action-metadata/definitions/prompt-manager.js';
import { recordActionInvocation } from '../../../tooling/action-metadata/usage-tracker.js';
import { ValidationError, PromptError, handleError as utilsHandleError, } from '../../../utils/index.js';
// Modular components
import { ComparisonEngine } from '../analysis/comparison-engine.js';
import { GateAnalyzer } from '../analysis/gate-analyzer.js';
import { PromptAnalyzer } from '../analysis/prompt-analyzer.js';
import { FileOperations } from '../operations/file-operations.js';
import { FilterParser } from '../search/filter-parser.js';
import { PromptMatcher } from '../search/prompt-matcher.js';
import { validateRequiredFields } from '../utils/validation.js';
const PROMPT_MANAGER_ACTIONS = promptManagerMetadata.data.actions;
const PROMPT_MANAGER_ACTION_MAP = new Map(PROMPT_MANAGER_ACTIONS.map((action) => [action.id, action]));
const GOAL_KEYWORDS = [
    {
        keywords: /gate|quality|review/i,
        actions: ['analyze_gates', 'update'],
    },
    { keywords: /create|add|new/i, actions: ['create'] },
    { keywords: /list|discover|catalog|show/i, actions: ['list'] },
    { keywords: /modify|edit|section/i, actions: ['update'] },
    { keywords: /delete|remove/i, actions: ['delete'] },
    { keywords: /reload|refresh/i, actions: ['reload'] },
];
// Legacy aliases fully retired; kept empty to avoid undefined references in summaries/warnings.
const LEGACY_ACTION_ALIASES = {};
/**
 * Consolidated Prompt Manager - Modular Architecture
 */
export class ConsolidatedPromptManager {
    constructor(logger, mcpServer, configManager, semanticAnalyzer, frameworkStateManager, frameworkManager, onRefresh, onRestart) {
        // Data references
        this.promptsData = [];
        this.convertedPrompts = [];
        this.categories = [];
        this.logger = logger;
        this.mcpServer = mcpServer;
        this.configManager = configManager;
        this.semanticAnalyzer = semanticAnalyzer;
        this.frameworkStateManager = frameworkStateManager;
        this.frameworkManager = frameworkManager;
        this.onRefresh = onRefresh;
        this.onRestart = onRestart;
        // Initialize modular components
        const dependencies = {
            logger,
            mcpServer,
            configManager,
            semanticAnalyzer,
            frameworkStateManager,
            frameworkManager,
            onRefresh,
            onRestart,
        };
        this.promptAnalyzer = new PromptAnalyzer(dependencies);
        this.comparisonEngine = new ComparisonEngine(logger);
        this.gateAnalyzer = new GateAnalyzer(dependencies);
        this.filterParser = new FilterParser(logger);
        this.promptMatcher = new PromptMatcher(logger);
        this.fileOperations = new FileOperations(dependencies);
        this.logger.debug('ConsolidatedPromptManager initialized with modular architecture');
    }
    /**
     * Update data references
     */
    updateData(promptsData, convertedPrompts, categories) {
        this.promptsData = promptsData;
        this.convertedPrompts = convertedPrompts;
        this.categories = categories;
        // Update modular components that need data references
        const data = {
            promptsData,
            convertedPrompts,
            categories,
        };
        // Components handle their own data updates if needed
        this.logger.debug(`Updated data references: ${promptsData.length} prompts, ${categories.length} categories`);
    }
    /**
     * Set framework state manager (called during initialization)
     */
    setFrameworkStateManager(frameworkStateManager) {
        this.frameworkStateManager = frameworkStateManager;
        this.logger.debug('Framework state manager set in PromptManager');
    }
    /**
     * Set framework manager (called during initialization)
     */
    setFrameworkManager(frameworkManager) {
        this.frameworkManager = frameworkManager;
        this.logger.debug('Framework manager set in PromptManager');
    }
    /**
     * Main action handler - Routes to appropriate modules
     */
    async handleAction(args, extra) {
        const { action } = args;
        // USING ERROR LEVEL FOR GUARANTEED VISIBILITY IN LOGS
        this.logger.error(`[GATE-TRACE] ðŸš€ ENTRY POINT: handleAction called with action "${action}"`);
        this.logger.error(`[GATE-TRACE] Gate config present: ${!!args.gate_configuration}, Type: ${typeof args.gate_configuration}`);
        this.logger.info(`ðŸ“ Prompt Manager: Executing action "${action}"`);
        recordActionInvocation('prompt_manager', action, 'received');
        try {
            let response;
            switch (action) {
                case 'create':
                    response = await this.createPrompt(args);
                    break;
                case 'analyze_type':
                    response = await this.analyzePromptType(args);
                    break;
                case 'update':
                    response = await this.updatePrompt(args);
                    break;
                case 'delete':
                    response = await this.deletePrompt(args);
                    break;
                case 'reload':
                    response = await this.reloadPrompts(args);
                    break;
                case 'list':
                    response = await this.listPrompts(args);
                    break;
                case 'inspect':
                    response = await this.inspectPrompt(args);
                    break;
                case 'analyze_gates':
                    response = await this.analyzePromptGates(args);
                    break;
                case 'guide':
                    response = await this.guidePromptActions(args);
                    break;
                default:
                    recordActionInvocation('prompt_manager', action, 'unknown');
                    throw new ValidationError(`Unknown action: ${action}`);
            }
            response = this.appendActionWarnings(response, action);
            recordActionInvocation('prompt_manager', action, 'success');
            return response;
        }
        catch (error) {
            recordActionInvocation('prompt_manager', action, 'failure', {
                error: error instanceof Error ? error.message : String(error),
            });
            return this.handleError(error, action);
        }
    }
    /**
     * Create new prompt (delegates to file operations and analysis)
     */
    async createPrompt(args) {
        validateRequiredFields(args, ['id', 'name', 'description', 'user_message_template']);
        // Create prompt data with enhanced gate configuration support
        const promptData = {
            id: args.id,
            name: args.name,
            category: args.category || 'general',
            description: args.description,
            systemMessage: args.system_message,
            userMessageTemplate: args.user_message_template,
            arguments: args.arguments || [],
            isChain: args.is_chain || false,
            chainSteps: args.chain_steps || [],
            gateConfiguration: args.gate_configuration || args.gates,
        };
        // USING ERROR LEVEL FOR GUARANTEED VISIBILITY
        this.logger.error(`[GATE-TRACE] ðŸ“‹ createPrompt constructed promptData for ${args.id}`);
        this.logger.error(`[GATE-TRACE] promptData final structure:`, {
            id: promptData.id,
            hasGateConfiguration: !!promptData.gateConfiguration,
            gateConfigType: typeof promptData.gateConfiguration,
            gateConfigValue: promptData.gateConfiguration,
            argsGateConfig: args.gate_configuration,
            argsGates: args.gates,
        });
        this.logger.error(`[GATE-TRACE] ðŸ“ Calling fileOperations.updatePromptImplementation for ${args.id}`);
        const result = await this.fileOperations.updatePromptImplementation(promptData);
        // Perform intelligent analysis
        const analysis = await this.promptAnalyzer.analyzePromptIntelligence(promptData);
        let response = `âœ… **Prompt Created**: ${args.name} (${args.id})\n`;
        response += `ðŸ“ ${args.description}\n`;
        response += `${analysis.feedback}`;
        if (analysis.suggestions.length > 0) {
            response += `ðŸ’¡ ${analysis.suggestions.join(' â€¢ ')}\n`;
        }
        // Enhanced: Gate configuration analysis and suggestions
        if (promptData.gateConfiguration) {
            response += `\nðŸ”’ **Gate Configuration Applied**:\n`;
            if (promptData.gateConfiguration.include) {
                response += `- Include Gates: ${promptData.gateConfiguration.include.join(', ')}\n`;
            }
            if (promptData.gateConfiguration.inline_gate_definitions) {
                response += `- Inline Gate Definitions: ${promptData.gateConfiguration.inline_gate_definitions.length} defined\n`;
            }
        }
        else if (this.semanticAnalyzer.isLLMEnabled()) {
            // Suggest gate configuration for prompts without gates (only when API analysis is enabled)
            try {
                const gateAnalysis = await this.gateAnalyzer.analyzePromptForGates({
                    id: promptData.id,
                    name: promptData.name,
                    category: promptData.category,
                    description: promptData.description,
                    userMessageTemplate: promptData.userMessageTemplate,
                    systemMessage: promptData.systemMessage,
                    arguments: promptData.arguments || [],
                });
                if (gateAnalysis.recommendedGates.length > 0) {
                    response += `\nðŸ’¡ **Suggested Gates**: Consider adding these gates:\n`;
                    gateAnalysis.recommendedGates.slice(0, 3).forEach((gate) => {
                        response += `- ${gate}\n`;
                    });
                    response += `Use \`update\` action with \`gate_configuration\` parameter to add gates.\n`;
                }
            }
            catch (error) {
                this.logger.warn('Failed to analyze gates for new prompt:', error);
            }
        }
        await this.handleSystemRefresh(args.full_restart, `Prompt created: ${args.id}`);
        return {
            content: [{ type: 'text', text: response }],
            isError: false,
        };
    }
    /**
     * Update existing prompt (delegates to file operations and comparison)
     */
    async updatePrompt(args) {
        validateRequiredFields(args, ['id']);
        // Get current prompt for comparison
        const currentPrompt = this.convertedPrompts.find((p) => p.id === args.id);
        let beforeAnalysis = null;
        if (currentPrompt) {
            beforeAnalysis = await this.promptAnalyzer.analyzePrompt(currentPrompt);
        }
        // Update prompt data with enhanced gate configuration support
        const promptData = {
            id: args.id,
            name: args.name || currentPrompt?.name || args.id,
            category: args.category || currentPrompt?.category || 'general',
            description: args.description || currentPrompt?.description || '',
            systemMessage: args.system_message || currentPrompt?.systemMessage,
            userMessageTemplate: args.user_message_template || currentPrompt?.userMessageTemplate || '',
            arguments: args.arguments || currentPrompt?.arguments || [],
            chainSteps: args.chain_steps || currentPrompt?.chainSteps || [],
            gateConfiguration: args.gate_configuration || args.gates || currentPrompt?.gateConfiguration,
        };
        const result = await this.fileOperations.updatePromptImplementation(promptData);
        // Perform analysis comparison
        const afterAnalysis = await this.promptAnalyzer.analyzePromptIntelligence(promptData);
        let response = `âœ… **Prompt Updated**: ${promptData.name} (${args.id})\n\n`;
        response += `${result.message}\n\n`;
        response += `${afterAnalysis.feedback}\n`;
        // Add comparison if we have before analysis
        if (beforeAnalysis) {
            const comparison = this.comparisonEngine.compareAnalyses(beforeAnalysis, afterAnalysis.classification, args.id);
            const displaySummary = this.comparisonEngine.generateDisplaySummary(comparison);
            if (displaySummary) {
                response += `\n${displaySummary}\n`;
            }
        }
        if (afterAnalysis.suggestions.length > 0) {
            response += `\nðŸ’¡ **Improvement Suggestions**:\n`;
            afterAnalysis.suggestions.forEach((suggestion, i) => {
                response += `${i + 1}. ${suggestion}\n`;
            });
        }
        await this.handleSystemRefresh(args.full_restart, `Prompt updated: ${args.id}`);
        return {
            content: [{ type: 'text', text: response }],
            isError: false,
        };
    }
    /**
     * Delete prompt with safety checks (delegates to file operations)
     */
    async deletePrompt(args) {
        validateRequiredFields(args, ['id']);
        const promptToDelete = this.promptsData.find((p) => p.id === args.id);
        if (!promptToDelete) {
            throw new PromptError(`Prompt not found: ${args.id}`);
        }
        // Safety check - analyze dependencies
        const dependencies = this.findPromptDependencies(args.id);
        let response = `ðŸ—‘ï¸ **Deleting Prompt**: ${promptToDelete.name} (${args.id})\n\n`;
        if (dependencies.length > 0) {
            response += `âš ï¸ **Warning**: This prompt is referenced by ${dependencies.length} other prompts:\n`;
            dependencies.forEach((dep) => {
                response += `- ${dep.name} (${dep.id})\n`;
            });
            response += `\nDeleting will break these chain references.\n\n`;
        }
        const result = await this.fileOperations.deletePromptImplementation(args.id);
        response += `${result.message}\n\n`;
        response += `âœ… **Prompt successfully removed from system**\n`;
        await this.handleSystemRefresh(args.full_restart, `Prompt deleted: ${args.id}`);
        return {
            content: [{ type: 'text', text: response }],
            isError: false,
        };
    }
    /**
     * List prompts with intelligent filtering (delegates to search modules)
     */
    async listPrompts(args) {
        this.logger.debug(`[PromptManager] List prompts called with search_query: "${args.search_query || ''}"`);
        const filters = this.filterParser.parseIntelligentFilters(args.search_query || '');
        this.logger.debug('[PromptManager] Parsed filters', filters);
        const matchingPrompts = [];
        // Process all prompts using matcher
        this.logger.debug(`[PromptManager] Processing ${this.convertedPrompts.length} prompts`);
        for (const prompt of this.convertedPrompts) {
            try {
                const classification = await this.promptAnalyzer.analyzePrompt(prompt);
                this.logger.debug(`[PromptManager] Analyzing prompt ${prompt.id}, type: ${classification.executionType}`);
                // Apply filters using matcher
                const matches = await this.promptMatcher.matchesFilters(prompt, filters, classification);
                this.logger.debug(`[PromptManager] Prompt ${prompt.id} matches filters: ${matches}`);
                if (matches) {
                    matchingPrompts.push({ prompt, classification });
                }
            }
            catch (error) {
                this.logger.warn(`Failed to analyze prompt ${prompt.id}:`, error);
            }
        }
        // Sort by relevance
        matchingPrompts.sort((a, b) => {
            const scoreA = this.promptMatcher.calculateRelevanceScore(a.prompt, a.classification, filters);
            const scoreB = this.promptMatcher.calculateRelevanceScore(b.prompt, b.classification, filters);
            return scoreB - scoreA; // Higher scores first
        });
        if (matchingPrompts.length === 0) {
            return {
                content: [
                    {
                        type: 'text',
                        text: `ðŸ“­ No prompts found matching filter: "${args.search_query || 'all'}"\n\nðŸ’¡ Try broader search terms or use filters like 'type:template', 'category:analysis'`,
                    },
                ],
                isError: false,
            };
        }
        // Generate response using existing format
        let result = `ðŸ“š **Prompt Library** (${matchingPrompts.length} prompts)\n\n`;
        // Group by category for better organization
        const groupedByCategory = matchingPrompts.reduce((acc, item) => {
            const category = item.prompt.category || 'uncategorized';
            if (!acc[category])
                acc[category] = [];
            acc[category].push(item);
            return acc;
        }, {});
        for (const [category, prompts] of Object.entries(groupedByCategory)) {
            result += `\n## ðŸ“ ${category.toUpperCase()}\n`;
            for (const { prompt, classification } of prompts) {
                const executionIcon = this.getExecutionTypeIcon(classification.executionType);
                const frameworkIcon = classification.requiresFramework ? 'ðŸ§ ' : 'âš¡';
                result += `\n**${executionIcon} ${prompt.name}** \`${prompt.id}\`\n`;
                result += `   ${frameworkIcon} **Type**: ${classification.executionType}\n`;
                if (prompt.description) {
                    const shortDesc = prompt.description.length > 80
                        ? prompt.description.substring(0, 80) + '...'
                        : prompt.description;
                    result += `   ðŸ“ ${shortDesc}\n`;
                }
                if (prompt.arguments?.length > 0) {
                    result += `   ðŸ”§ **Args**: ${prompt.arguments.map((arg) => arg.name).join(', ')}\n`;
                }
            }
        }
        // Add filter summary if filters were applied
        if (args.filter) {
            const filterDescriptions = this.filterParser.buildFilterDescription(filters);
            if (filterDescriptions.length > 0) {
                result += `\n\nðŸ” **Applied Filters**:\n`;
                filterDescriptions.forEach((desc) => {
                    result += `- ${desc}\n`;
                });
            }
        }
        result += `\n\nðŸ’¡ **Usage Tips**:\n`;
        result += `â€¢ Use \`>>prompt_id\` to execute prompts\n`;
        result += `â€¢ Use \`analyze_type\` to get type recommendations\n`;
        return {
            content: [{ type: 'text', text: result }],
            isError: false,
        };
    }
    /**
     * Analyze prompt type (delegates to analysis module)
     */
    async analyzePromptType(args) {
        validateRequiredFields(args, ['id']);
        const prompt = this.convertedPrompts.find((p) => p.id === args.id);
        if (!prompt) {
            return {
                content: [{ type: 'text', text: `Prompt not found: ${args.id}` }],
                isError: true,
            };
        }
        const analysis = await this.promptAnalyzer.analyzePrompt(prompt);
        let recommendation = `ðŸ” **Prompt Type Analysis**: ${prompt.name}\n\n`;
        recommendation += `ðŸ“Š **Normalized Execution Type**: ${analysis.executionType}\n`;
        recommendation += `ðŸ§  **Framework Recommended**: ${analysis.requiresFramework ? 'Yes' : 'No'}\n\n`;
        recommendation += `ðŸ“‹ **Analysis Details**:\n`;
        analysis.reasoning.forEach((reason, i) => {
            recommendation += `${i + 1}. ${reason}\n`;
        });
        recommendation += `\nðŸ”„ **Recommendations**:\n`;
        recommendation += `âœ… **Well-aligned**: Current execution type matches content appropriately\n`;
        if (analysis.suggestedGates.length > 0) {
            recommendation += `\nðŸ”’ **Suggested Quality Gates**: ${analysis.suggestedGates.join(', ')}\n`;
        }
        return {
            content: [{ type: 'text', text: recommendation }],
            isError: false,
        };
    }
    /**
     * Inspect a single prompt by id.
     */
    async inspectPrompt(args) {
        validateRequiredFields(args, ['id']);
        const prompt = this.convertedPrompts.find((p) => p.id === args.id);
        if (!prompt) {
            return {
                content: [{ type: 'text', text: `Prompt not found: ${args.id}` }],
                isError: true,
            };
        }
        const classification = await this.promptAnalyzer.analyzePrompt(prompt);
        const gateConfig = prompt.gateConfiguration;
        let response = `ðŸ” **Prompt Inspect**: ${prompt.name} (\`${prompt.id}\`)\n\n`;
        response += `âš¡ **Type**: ${classification.executionType}\n`;
        response += `ðŸ§  **Requires Framework**: ${classification.requiresFramework ? 'Yes' : 'No'}\n`;
        if (prompt.description) {
            response += `ðŸ“ **Description**: ${prompt.description}\n`;
        }
        if (prompt.arguments?.length) {
            response += `ðŸ”§ **Arguments**: ${prompt.arguments.map((arg) => arg.name).join(', ')}\n`;
        }
        if (prompt.chainSteps?.length) {
            response += `ðŸ”— **Chain Steps**: ${prompt.chainSteps.length}\n`;
        }
        if (gateConfig) {
            response += `ðŸ›¡ï¸ **Gates**: ${JSON.stringify(gateConfig)}\n`;
        }
        return {
            content: [{ type: 'text', text: response }],
            isError: false,
        };
    }
    // Additional helper methods (maintaining original API)
    async reloadPrompts(args) {
        const reason = args.reason || 'Manual reload requested';
        let response = `ðŸ”„ **Reloading Prompts System**\n\n`;
        response += `**Reason**: ${reason}\n`;
        response += `**Mode**: ${args.full_restart ? 'Full Server Restart' : 'Hot Reload'}\n\n`;
        if (args.full_restart) {
            setTimeout(() => this.onRestart(reason), 1000);
            response += `âš¡ **Server restart initiated**... Please wait for reconnection.\n`;
        }
        else {
            await this.onRefresh();
            response += `âœ… **Hot reload completed** - All prompts refreshed from disk.\n`;
        }
        return { content: [{ type: 'text', text: response }], isError: false };
    }
    // Helper methods
    findPromptDependencies(promptId) {
        return this.convertedPrompts.filter((prompt) => {
            if (!prompt.chainSteps || prompt.chainSteps.length === 0)
                return false;
            return prompt.chainSteps.some((step) => step.promptId === promptId);
        });
    }
    getExecutionTypeIcon(executionType) {
        if (executionType === 'chain') {
            return 'ðŸ”—';
        }
        return 'âš¡';
    }
    async handleSystemRefresh(fullRestart = false, reason) {
        if (fullRestart) {
            setTimeout(() => this.onRestart(reason), 1000);
        }
        else {
            await this.onRefresh();
        }
    }
    /**
     * Analyze prompt gates and provide recommendations
     */
    async analyzePromptGates(args) {
        validateRequiredFields(args, ['id']);
        const prompt = this.convertedPrompts.find((p) => p.id === args.id);
        if (!prompt) {
            return {
                content: [{ type: 'text', text: `Prompt not found: ${args.id}` }],
                isError: true,
            };
        }
        const analysis = await this.gateAnalyzer.analyzePromptForGates(prompt);
        const totalGatesCount = analysis.recommendedGates.length + analysis.suggestedTemporaryGates.length;
        let response = `Gate Analysis: ${prompt.name}\n\n`;
        // Consolidated gates section
        if (totalGatesCount > 0) {
            response += `Recommended Gates (${totalGatesCount} total):\n`;
            // List persistent gates
            analysis.recommendedGates.forEach((gate) => {
                response += `â€¢ ${gate}\n`;
            });
            // List temporary gates with scope indicators
            analysis.suggestedTemporaryGates.forEach((gate) => {
                response += `â€¢ ${gate.name} (temporary, ${gate.scope} scope)\n`;
            });
            response += `\n`;
        }
        else {
            response += `No specific gate recommendations for this prompt.\n\n`;
        }
        // Gate configuration JSON
        response += `Gate Configuration:\n`;
        response += `\`\`\`json\n${JSON.stringify(analysis.gateConfigurationPreview, null, 2)}\n\`\`\`\n`;
        return { content: [{ type: 'text', text: response }], isError: false };
    }
    async guidePromptActions(args) {
        const goal = typeof args.goal === 'string' ? args.goal.trim() : '';
        const includeLegacy = args.include_legacy === true;
        const rankedActions = this.rankActionsForGuide(goal, includeLegacy);
        const recommended = rankedActions.slice(0, Math.min(4, rankedActions.length));
        const quickReference = rankedActions.slice(0, Math.min(8, rankedActions.length));
        const highRisk = PROMPT_MANAGER_ACTIONS.filter((action) => action.status !== 'working' && action.id !== 'guide');
        const sections = [];
        sections.push('ðŸ§­ **Prompt Manager Guide**');
        sections.push(goal
            ? `ðŸŽ¯ **Goal**: ${goal}`
            : 'ðŸŽ¯ **Goal**: Provide authoring/lifecycle assistance using canonical actions.');
        if (recommended.length > 0) {
            sections.push('### Recommended Actions');
            recommended.forEach((action) => {
                sections.push(this.formatActionSummary(action));
            });
        }
        if (quickReference.length > 0) {
            sections.push('### Quick Reference');
            quickReference.forEach((action) => {
                const argsText = action.requiredArgs.length > 0 ? action.requiredArgs.join(', ') : 'None';
                sections.push(`- \`${action.id}\` (${this.describeActionStatus(action)}) â€” Required: ${argsText}`);
            });
        }
        if (highRisk.length > 0 && !includeLegacy) {
            sections.push('### Heads-Up (Advanced or Unstable Actions)');
            highRisk.slice(0, 3).forEach((action) => {
                const issueText = action.issues && action.issues.length > 0
                    ? `Issues: ${action.issues.map((issue) => issue.summary).join(', ')}`
                    : 'Advanced workflow.';
                sections.push(`- \`${action.id}\`: ${issueText}`);
            });
            sections.push('Set `include_legacy:true` to see full details on advanced actions.');
        }
        sections.push('ðŸ’¡ Use `prompt_manager(action:"<id>", ...)` with the required arguments above.');
        return {
            content: [{ type: 'text', text: sections.join('\n\n') }],
            isError: false,
        };
    }
    rankActionsForGuide(goal, includeLegacy) {
        const normalizedGoal = goal.toLowerCase();
        const candidates = PROMPT_MANAGER_ACTIONS.filter((action) => action.id !== 'guide' &&
            (includeLegacy || action.status === 'working' || action.id === 'list'));
        const scored = candidates.map((action) => ({
            action,
            score: this.computeGuideScore(action, normalizedGoal),
        }));
        return scored.sort((a, b) => b.score - a.score).map((entry) => entry.action);
    }
    computeGuideScore(action, normalizedGoal) {
        let score = action.status === 'working' ? 5 : 2;
        if (!normalizedGoal) {
            if (action.category === 'lifecycle') {
                score += 1;
            }
            if (action.id === 'list') {
                score += 1;
            }
            return score;
        }
        if (action.description.toLowerCase().includes(normalizedGoal)) {
            score += 3;
        }
        if (normalizedGoal.includes(action.id.replace(/_/g, ' '))) {
            score += 2;
        }
        for (const matcher of GOAL_KEYWORDS) {
            if (matcher.keywords.test(normalizedGoal) &&
                matcher.actions.includes(action.id)) {
                score += 6;
            }
        }
        return score;
    }
    formatActionSummary(action) {
        const argsText = action.requiredArgs.length > 0 ? action.requiredArgs.join(', ') : 'None';
        const status = this.describeActionStatus(action);
        let summary = `- \`${action.id}\` (${status}) â€” ${action.description}\n  Required: ${argsText}`;
        if (action.issues && action.issues.length > 0) {
            const issueList = action.issues
                .map((issue) => `${issue.severity === 'high' ? 'â—' : 'âš ï¸'} ${issue.summary}`)
                .join(' â€¢ ');
            summary += `\n  Issues: ${issueList}`;
        }
        if (LEGACY_ACTION_ALIASES[action.id]) {
            summary += `\n  âž¡ï¸ Prefer action="${LEGACY_ACTION_ALIASES[action.id]}" for canonical workflows.`;
        }
        return summary;
    }
    describeActionStatus(action) {
        switch (action.status) {
            case 'working':
                return 'âœ… Working';
            case 'planned':
                return 'ðŸ—ºï¸ Planned';
            case 'untested':
                return 'ðŸ§ª Untested';
            case 'deprecated':
                return 'ðŸ›‘ Deprecated';
            default:
                return `âš ï¸ ${action.status}`;
        }
    }
    appendActionWarnings(response, actionId) {
        const descriptor = PROMPT_MANAGER_ACTION_MAP.get(actionId);
        if (!descriptor) {
            return response;
        }
        const warnings = [];
        if (descriptor.status !== 'working') {
            warnings.push(`Status: ${this.describeActionStatus(descriptor)}`);
        }
        if (descriptor.issues && descriptor.issues.length > 0) {
            descriptor.issues.forEach((issue) => {
                warnings.push(`${issue.severity === 'high' ? 'â—' : 'âš ï¸'} ${issue.summary}`);
            });
        }
        if (LEGACY_ACTION_ALIASES[actionId]) {
            warnings.push(`Prefer action="${LEGACY_ACTION_ALIASES[actionId]}" for canonical workflows.`);
        }
        if (warnings.length === 0) {
            return response;
        }
        const originalText = response.content?.[0]?.text ?? '';
        const note = `\n\n---\nâš ï¸ **Action Notes (${descriptor.displayName})**\n${warnings
            .map((warning) => `- ${warning}`)
            .join('\n')}`;
        return {
            ...response,
            content: [{ type: 'text', text: `${originalText}${note}` }],
            isError: response.isError,
        };
    }
    handleError(error, context) {
        const { message, isError } = utilsHandleError(error, context, this.logger);
        return { content: [{ type: 'text', text: message }], isError: true };
    }
}
/**
 * Create consolidated prompt manager - maintains original factory function API
 */
export function createConsolidatedPromptManager(logger, mcpServer, configManager, semanticAnalyzer, frameworkStateManager, frameworkManager, onRefresh, onRestart) {
    return new ConsolidatedPromptManager(logger, mcpServer, configManager, semanticAnalyzer, frameworkStateManager, frameworkManager, onRefresh, onRestart);
}
//# sourceMappingURL=manager.js.map