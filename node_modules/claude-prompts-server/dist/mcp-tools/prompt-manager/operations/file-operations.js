// @lifecycle canonical - Handles prompt file read/write operations.
/**
 * File system and category management operations
 */
import * as fs from 'node:fs/promises';
import { readFile } from 'node:fs/promises';
import * as path from 'node:path';
import { cleanupEmptyCategoryOnDisk, ensureCategoryExistsOnDisk, getCategoryStatsFromDisk, validateCategoryStructureOnDisk, } from '../../../prompts/category-maintenance.js';
import { buildPromptBaseContent, buildPromptMarkdownContent, buildGateConfigurationSection, buildChainStepsSection, } from '../../../prompts/prompt-writer.js';
import { safeWriteFile } from '../../../prompts/promptUtils.js';
/**
 * File system operations for prompt management
 */
export class FileOperations {
    constructor(dependencies) {
        this.logger = dependencies.logger;
        this.configManager = dependencies.configManager;
    }
    /**
     * Update prompt implementation (shared by create/update)
     */
    async updatePromptImplementation(promptData) {
        const PROMPTS_FILE = this.configManager.getPromptsFilePath();
        const messages = [];
        const fileContent = await readFile(PROMPTS_FILE, 'utf8');
        const promptsConfig = JSON.parse(fileContent);
        if (!promptsConfig.categories)
            promptsConfig.categories = [];
        if (!promptsConfig.imports)
            promptsConfig.imports = [];
        // Ensure category exists
        const { effectiveCategory, created: categoryCreated } = await ensureCategoryExistsOnDisk({
            logger: this.logger,
            category: promptData.category,
            promptsConfig,
            promptsFile: PROMPTS_FILE,
        });
        if (categoryCreated) {
            messages.push(`âœ… Created category: '${effectiveCategory}'`);
        }
        // Create/update prompt file
        const { exists: promptExists } = await this.createOrUpdatePromptFile(promptData, effectiveCategory, PROMPTS_FILE);
        messages.push(`âœ… ${promptExists ? 'Updated' : 'Created'} prompt file and registry entry`);
        return {
            message: messages.join('\n'),
            affectedFiles: [`${promptData.id}.md`],
        };
    }
    /**
     * Delete prompt implementation
     */
    async deletePromptImplementation(id) {
        const PROMPTS_FILE = this.configManager.getPromptsFilePath();
        const promptsConfigDir = path.dirname(PROMPTS_FILE);
        const messages = [];
        const affectedFiles = [];
        const fileContent = await readFile(PROMPTS_FILE, 'utf8');
        const promptsConfig = JSON.parse(fileContent);
        let promptFound = false;
        // Search through category imports
        for (const categoryImport of promptsConfig.imports || []) {
            const categoryPath = path.join(promptsConfigDir, categoryImport);
            try {
                const categoryContent = await readFile(categoryPath, 'utf8');
                const categoryData = JSON.parse(categoryContent);
                const promptIndex = categoryData.prompts.findIndex((p) => p.id === id);
                if (promptIndex > -1) {
                    const promptEntry = categoryData.prompts[promptIndex];
                    // Remove from category
                    categoryData.prompts.splice(promptIndex, 1);
                    await safeWriteFile(categoryPath, JSON.stringify(categoryData, null, 2), 'utf8');
                    // Delete markdown file
                    const markdownPath = path.join(path.dirname(categoryPath), promptEntry.file);
                    try {
                        await fs.unlink(markdownPath);
                        messages.push(`âœ… Deleted prompt file: ${promptEntry.file}`);
                        affectedFiles.push(promptEntry.file);
                    }
                    catch (unlinkError) {
                        if (unlinkError.code !== 'ENOENT') {
                            messages.push(`âš ï¸ Could not delete file: ${unlinkError.message}`);
                        }
                    }
                    messages.push(`âœ… Removed from category: ${categoryImport}`);
                    promptFound = true;
                    // Automatically clean up empty category
                    if (categoryData.prompts.length === 0) {
                        this.logger.info(`Category ${categoryImport} is now empty, performing automatic cleanup`);
                        const cleanupMessage = await cleanupEmptyCategoryOnDisk({
                            logger: this.logger,
                            categoryImport,
                            promptsConfig,
                            promptsFile: PROMPTS_FILE,
                        });
                        messages.push(`ðŸ§¹ **Automatic Category Cleanup**:\n${cleanupMessage}`);
                    }
                    break;
                }
            }
            catch (error) {
                this.logger.warn(`Could not process category file: ${categoryPath}`, error);
            }
        }
        if (!promptFound) {
            throw new Error(`Prompt not found: ${id}`);
        }
        return {
            message: messages.join('\n'),
            affectedFiles,
        };
    }
    /**
     * Create or update prompt file
     */
    async createOrUpdatePromptFile(promptData, effectiveCategory, promptsFile) {
        const promptFilename = `${promptData.id}.md`;
        const categoryDir = path.join(path.dirname(promptsFile), effectiveCategory);
        const promptPath = path.join(categoryDir, promptFilename);
        // Create markdown content
        const promptBaseContent = buildPromptBaseContent({
            id: promptData.id,
            name: promptData.name,
            description: promptData.description,
            systemMessage: promptData.systemMessage,
            userMessageTemplate: promptData.userMessageTemplate,
        });
        this.logger.error(`[GATE-TRACE] ðŸ’¾ FILE-OPS Gate Configuration Check for ${promptData.id}:`, {
            hasGateConfiguration: !!promptData.gateConfiguration,
            gateConfigType: typeof promptData.gateConfiguration,
            gateConfigContent: promptData.gateConfiguration,
            promptId: promptData.id,
        });
        const gateConfigSection = buildGateConfigurationSection(promptData.gateConfiguration);
        if (gateConfigSection) {
            this.logger.error(`[GATE-TRACE] âœ… Building gate configuration section for prompt ${promptData.id}`);
            this.logger.error(`[GATE-TRACE] ðŸ“ Gate configuration JSON content:`, JSON.stringify(promptData.gateConfiguration, null, 2));
        }
        else {
            this.logger.error(`[GATE-TRACE] âŒ NO GATE CONFIGURATION FOUND for prompt ${promptData.id}`);
        }
        const chainStepsSection = buildChainStepsSection(promptData.chainSteps);
        let content = promptBaseContent;
        // Check if file exists and handle Gate Configuration replacement
        const existsBefore = await fs
            .access(promptPath)
            .then(() => true)
            .catch(() => false);
        if (existsBefore && gateConfigSection) {
            try {
                // Read existing file to preserve structure and replace Gate Configuration section
                const existingContent = await readFile(promptPath, 'utf8');
                // Remove ALL existing Gate Configuration sections (handles multiple duplicates)
                const gateConfigRegex = /## Gate Configuration\s*\n```json\s*\n[\s\S]*?\n```\s*/g;
                let cleanedContent = existingContent.replace(gateConfigRegex, '');
                // Find insertion point - after User Message Template, before Chain Steps or end
                const chainStepsIndex = cleanedContent.indexOf('## Chain Steps');
                if (chainStepsIndex > 0) {
                    // Insert gate config before Chain Steps
                    content =
                        cleanedContent.slice(0, chainStepsIndex).trimEnd() +
                            '\n' +
                            gateConfigSection +
                            '\n' +
                            cleanedContent.slice(chainStepsIndex);
                    this.logger.error(`[GATE-TRACE] âœ… Replaced Gate Configuration section (inserted before Chain Steps)`);
                }
                else {
                    // No Chain Steps - append at end
                    content = cleanedContent.trimEnd() + '\n' + gateConfigSection;
                    this.logger.error(`[GATE-TRACE] âœ… Replaced Gate Configuration section (appended at end)`);
                }
            }
            catch (readError) {
                // If read fails, fall back to full regeneration
                this.logger.warn(`[GATE-TRACE] âš ï¸ Failed to read existing file for section replacement, using full regeneration`, readError);
                content += gateConfigSection + chainStepsSection;
            }
        }
        else {
            // New file or no gate configuration - regenerate full document
            content = buildPromptMarkdownContent({
                id: promptData.id,
                name: promptData.name,
                description: promptData.description,
                systemMessage: promptData.systemMessage,
                userMessageTemplate: promptData.userMessageTemplate,
                gateConfiguration: promptData.gateConfiguration,
                chainSteps: promptData.chainSteps,
            });
            if (gateConfigSection) {
                this.logger.error(`[GATE-TRACE] âœ… Added Gate Configuration section to new file`);
            }
        }
        // Write markdown file
        await safeWriteFile(promptPath, content, 'utf8');
        // Update category prompts.json
        const categoryPromptsPath = path.join(categoryDir, 'prompts.json');
        let categoryData;
        try {
            const categoryContent = await readFile(categoryPromptsPath, 'utf8');
            categoryData = JSON.parse(categoryContent);
        }
        catch {
            categoryData = { prompts: [] };
        }
        const promptEntry = {
            id: promptData.id,
            name: promptData.name,
            category: effectiveCategory,
            description: promptData.description,
            file: promptFilename,
            arguments: promptData.arguments || [],
        };
        const existingIndex = categoryData.prompts.findIndex((p) => p.id === promptData.id);
        if (existingIndex > -1) {
            categoryData.prompts[existingIndex] = promptEntry;
        }
        else {
            categoryData.prompts.push(promptEntry);
        }
        await safeWriteFile(categoryPromptsPath, JSON.stringify(categoryData, null, 2), 'utf8');
        return {
            exists: existsBefore,
            path: promptPath,
        };
    }
    /**
     * Validate file system state
     */
    async validateFileSystemState() {
        const issues = [];
        const PROMPTS_FILE = this.configManager.getPromptsFilePath();
        try {
            // Check main config file
            const fileContent = await readFile(PROMPTS_FILE, 'utf8');
            const promptsConfig = JSON.parse(fileContent);
            // Validate categories and imports
            const stats = await getCategoryStatsFromDisk(promptsConfig.imports || [], PROMPTS_FILE);
            // Check each category structure
            for (const categoryImport of promptsConfig.imports || []) {
                const validation = await validateCategoryStructureOnDisk(categoryImport, PROMPTS_FILE);
                if (!validation.valid) {
                    issues.push(`Category ${categoryImport}: ${validation.issues.join(', ')}`);
                }
            }
            return {
                valid: issues.length === 0,
                issues,
                stats,
            };
        }
        catch (error) {
            issues.push(`Failed to validate file system: ${error instanceof Error ? error.message : String(error)}`);
            return {
                valid: false,
                issues,
                stats: {},
            };
        }
    }
    /**
     * Backup prompt files
     */
    async backupPrompts() {
        const PROMPTS_FILE = this.configManager.getPromptsFilePath();
        const promptsDir = path.dirname(PROMPTS_FILE);
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupDir = path.join(promptsDir, `backup-${timestamp}`);
        await fs.mkdir(backupDir, { recursive: true });
        // Copy main config
        await fs.copyFile(PROMPTS_FILE, path.join(backupDir, 'promptsConfig.json'));
        let fileCount = 1;
        // Copy all categories and their prompts
        const fileContent = await readFile(PROMPTS_FILE, 'utf8');
        const promptsConfig = JSON.parse(fileContent);
        for (const categoryImport of promptsConfig.imports || []) {
            const sourcePath = path.join(promptsDir, categoryImport);
            const targetPath = path.join(backupDir, categoryImport);
            // Create category directory in backup
            await fs.mkdir(path.dirname(targetPath), { recursive: true });
            try {
                // Copy category config
                await fs.copyFile(sourcePath, targetPath);
                fileCount++;
                // Copy all markdown files in category
                const categoryDir = path.dirname(sourcePath);
                const files = await fs.readdir(categoryDir);
                for (const file of files) {
                    if (file.endsWith('.md')) {
                        const sourceFile = path.join(categoryDir, file);
                        const targetFile = path.join(path.dirname(targetPath), file);
                        await fs.copyFile(sourceFile, targetFile);
                        fileCount++;
                    }
                }
            }
            catch (error) {
                this.logger.warn(`Failed to backup category ${categoryImport}:`, error);
            }
        }
        this.logger.info(`Created backup with ${fileCount} files at ${backupDir}`);
        return {
            backupPath: backupDir,
            fileCount,
        };
    }
    /**
     * Get file system statistics
     */
    async getFileSystemStats() {
        const PROMPTS_FILE = this.configManager.getPromptsFilePath();
        const promptsDir = path.dirname(PROMPTS_FILE);
        let totalCategories = 0;
        let totalPrompts = 0;
        let totalFiles = 0;
        let diskUsage = 0;
        try {
            const fileContent = await readFile(PROMPTS_FILE, 'utf8');
            const promptsConfig = JSON.parse(fileContent);
            totalCategories = promptsConfig.categories?.length || 0;
            const stats = await getCategoryStatsFromDisk(promptsConfig.imports || [], PROMPTS_FILE);
            totalPrompts = Object.values(stats).reduce((sum, count) => sum + count, 0);
            // Count files and calculate disk usage
            const calculateDirSize = async (dirPath) => {
                let files = 0;
                let size = 0;
                try {
                    const items = await fs.readdir(dirPath, { withFileTypes: true });
                    for (const item of items) {
                        const itemPath = path.join(dirPath, item.name);
                        if (item.isDirectory()) {
                            const subResult = await calculateDirSize(itemPath);
                            files += subResult.files;
                            size += subResult.size;
                        }
                        else {
                            files++;
                            const stat = await fs.stat(itemPath);
                            size += stat.size;
                        }
                    }
                }
                catch (error) {
                    // Ignore errors for inaccessible directories
                }
                return { files, size };
            };
            const dirStats = await calculateDirSize(promptsDir);
            totalFiles = dirStats.files;
            diskUsage = dirStats.size;
        }
        catch (error) {
            this.logger.warn('Failed to calculate file system stats:', error);
        }
        return {
            totalCategories,
            totalPrompts,
            totalFiles,
            diskUsage,
        };
    }
}
//# sourceMappingURL=file-operations.js.map