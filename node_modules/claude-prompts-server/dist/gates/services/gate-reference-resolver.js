/**
 * Resolves inline gate references by checking whether they match
 * canonical gate definitions or should remain inline criteria.
 *
 * Gate resolution is now fully dynamic - gates are identified by loading
 * from the definitions directory via GateLoader. No hardcoded gate sets.
 */
export class GateReferenceResolver {
    constructor(gateLoader) {
        this.gateLoader = gateLoader;
        this.cache = new Map();
    }
    async resolve(reference) {
        const normalized = reference?.trim();
        if (!normalized) {
            return { referenceType: 'inline', criteria: '' };
        }
        const cached = this.cache.get(normalized);
        if (cached) {
            return cached;
        }
        const resolution = await this.computeResolution(normalized);
        this.cache.set(normalized, resolution);
        return resolution;
    }
    async computeResolution(value) {
        if (this.isGateSlug(value)) {
            const candidateIds = this.buildCandidates(value);
            for (const candidate of candidateIds) {
                const gate = await this.gateLoader.loadGate(candidate);
                if (gate) {
                    return {
                        referenceType: 'registered',
                        gateId: gate.id,
                    };
                }
            }
        }
        return {
            referenceType: 'inline',
            criteria: value,
        };
    }
    isGateSlug(value) {
        return /^[A-Za-z0-9_-]+$/.test(value);
    }
    buildCandidates(value) {
        const lowerCase = value.toLowerCase();
        if (value === lowerCase) {
            return [value];
        }
        return [value, lowerCase];
    }
}
//# sourceMappingURL=gate-reference-resolver.js.map