/**
 * Temporary Gate Registry
 *
 * Manages in-memory storage and lifecycle for execution-scoped gates that don't persist to filesystem.
 * Provides automatic cleanup, scope management, and integration with existing gate systems.
 */
import { Logger } from '../../logging/index.js';
import type { GateDefinition, LightweightGateDefinition } from '../types.js';
/**
 * Temporary gate definition with lifecycle management
 */
export interface TemporaryGateDefinition {
    /**
     * Unique identifier
     * - Auto-generated (temp_${timestamp}_${random}) if not provided
     * - User-provided IDs must not match auto-generated pattern to avoid collisions
     * - Must match /^[A-Za-z0-9_-]+$/ pattern
     */
    id: string;
    /** Human-readable name */
    name: string;
    /** Gate type */
    type: 'validation' | 'approval' | 'condition' | 'quality' | 'guidance';
    /** Scope of the temporary gate */
    scope: 'execution' | 'session' | 'chain' | 'step';
    /** Description of what this gate checks/guides */
    description: string;
    /** Guidance text injected into prompts */
    guidance: string;
    /** Pass/fail criteria for validation gates */
    pass_criteria?: any[];
    /** Creation timestamp */
    created_at: number;
    /** Expiration timestamp (optional) */
    expires_at?: number;
    /** Source of gate creation */
    source: 'manual' | 'automatic' | 'analysis';
    /** Additional context for gate creation */
    context?: Record<string, any>;
    /** Associated execution/session/chain ID */
    scope_id?: string;
    /** Target specific step number in a chain (1-based) */
    target_step_number?: number;
    /** Target multiple specific steps in a chain (1-based) */
    apply_to_steps?: number[];
}
/**
 * Registry for managing temporary gates
 */
export declare class TemporaryGateRegistry {
    private logger;
    private temporaryGates;
    private scopeManagement;
    private cleanupTimers;
    private maxMemoryGates;
    private defaultExpirationMs;
    constructor(logger: Logger, options?: {
        maxMemoryGates?: number;
        defaultExpirationMs?: number;
    });
    /**
     * Create a new temporary gate
     */
    createTemporaryGate(definition: Omit<TemporaryGateDefinition, 'id' | 'created_at'> & {
        id?: string;
    }, scopeId?: string): string;
    /**
     * Get a temporary gate by ID
     */
    getTemporaryGate(gateId: string): TemporaryGateDefinition | undefined;
    /**
     * Get all temporary gates for a specific scope
     */
    getTemporaryGatesForScope(scope: string, scopeId: string): TemporaryGateDefinition[];
    /**
     * Get all active temporary gates
     */
    getAllTemporaryGates(): TemporaryGateDefinition[];
    /**
     * Convert temporary gate to standard gate definition
     */
    convertToStandardGate(tempGate: TemporaryGateDefinition): GateDefinition;
    convertToLightweightGate(tempGate: TemporaryGateDefinition): LightweightGateDefinition;
    /**
     * Remove a temporary gate
     */
    removeTemporaryGate(gateId: string): boolean;
    /**
     * Clean up expired gates and scopes
     */
    cleanupExpiredGates(): number;
    /**
     * Clean up all gates for a specific scope
     */
    cleanupScope(scope: string, scopeId?: string): number;
    /**
     * Clean up all gates for a chain execution
     * Removes all chain-scoped gates and associated step-scoped gates
     */
    cleanupChainExecution(chainExecutionId: string): number;
    /**
     * Clean up all gates for an execution scope
     * Convenience method for execution-scoped cleanups
     */
    cleanupExecutionScope(executionId: string): number;
    /**
     * Get registry statistics
     */
    getStatistics(): {
        totalGates: number;
        maxCapacity: number;
        utilizationPercent: number;
        expiredGates: number;
        activeScopes: number;
        activeCleanupTimers: number;
        gatesByScope: Record<string, number>;
        gatesBySource: Record<string, number>;
        memoryUsageEstimate: number;
    };
    /**
     * Force cleanup to free memory
     */
    private performCleanup;
    /**
     * Associate gate with scope
     */
    private associateWithScope;
    /**
     * Remove gate from scope
     */
    private removeFromScope;
    /**
     * Cleanup scope by key
     */
    private cleanupScopeByKey;
    /**
     * Estimate memory usage
     */
    private estimateMemoryUsage;
    /**
     * Validate user-provided custom ID
     * Prevents collision with auto-generated IDs and enforces format requirements
     */
    private isValidCustomId;
    /**
     * Cleanup all resources
     */
    destroy(): void;
}
/**
 * Factory function for creating temporary gate registry
 */
export declare function createTemporaryGateRegistry(logger: Logger, options?: {
    maxMemoryGates?: number;
    defaultExpirationMs?: number;
}): TemporaryGateRegistry;
