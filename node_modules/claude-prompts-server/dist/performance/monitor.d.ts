/**
 * Performance Monitoring System
 *
 * Comprehensive performance tracking and optimization for the MCP server
 * Focuses on execution metrics, memory usage, and system health monitoring
 */
import { Logger } from '../logging/index.js';
export interface PerformanceMetrics {
    timestamp: number;
    memory: {
        heapUsed: number;
        heapTotal: number;
        external: number;
        rss: number;
    };
    execution: {
        totalExecutions: number;
        averageExecutionTime: number;
        successRate: number;
        activeExecutions: number;
    };
    system: {
        uptime: number;
        cpuUsage: number[];
        loadAverage: number[];
    };
    chains: {
        activeChains: number;
        averageChainLength: number;
        chainSuccessRate: number;
        averageChainExecutionTime: number;
    };
}
export interface PerformanceThresholds {
    memoryThreshold: number;
    executionTimeThreshold: number;
    successRateThreshold: number;
    chainExecutionTimeThreshold: number;
}
export interface PerformanceAlert {
    level: 'warning' | 'error' | 'critical';
    category: 'memory' | 'execution' | 'chains' | 'system';
    message: string;
    timestamp: number;
    metrics?: Partial<PerformanceMetrics>;
    recommendation?: string;
}
/**
 * Performance monitoring and optimization system
 */
export declare class PerformanceMonitor {
    private logger;
    private metricsHistory;
    private maxHistorySize;
    private monitoringInterval?;
    private alertingCallbacks;
    private thresholds;
    private previousCpuUsage;
    private previousCpuTime;
    private optimizationScheduled;
    private lastOptimization;
    private optimizationInterval;
    constructor(logger: Logger, thresholds?: Partial<PerformanceThresholds>);
    /**
     * Check if we're running in a test environment
     */
    private isTestEnvironment;
    /**
     * Start performance monitoring
     * SUPPRESSED in test environments to prevent hanging processes
     */
    startMonitoring(intervalMs?: number): void;
    /**
     * Stop performance monitoring
     */
    stopMonitoring(): void;
    /**
     * Collect current performance metrics
     */
    collectMetrics(): PerformanceMetrics;
    /**
     * Get performance metrics history
     */
    getMetricsHistory(count?: number): PerformanceMetrics[];
    /**
     * Get latest performance metrics
     */
    getLatestMetrics(): PerformanceMetrics | undefined;
    /**
     * Register alerting callback
     */
    onAlert(callback: (alert: PerformanceAlert) => void): void;
    /**
     * Get performance summary over time period
     */
    getPerformanceSummary(periodMs?: number): {
        averageMemory: number;
        peakMemory: number;
        averageExecutionTime: number;
        totalExecutions: number;
        successRate: number;
        alertsGenerated: number;
    } | undefined;
    /**
     * Force performance optimization
     */
    optimizePerformance(): Promise<{
        memoryFreed: number;
        optimizationsApplied: string[];
    }>;
    /**
     * Calculate chain-specific metrics
     */
    private calculateChainMetrics;
    /**
     * Check performance thresholds and generate alerts
     */
    private checkThresholds;
    /**
     * Schedule performance optimization if needed
     */
    private scheduleOptimization;
}
/**
 * Factory function to create a performance monitor
 */
export declare function createPerformanceMonitor(logger: Logger, thresholds?: Partial<PerformanceThresholds>): PerformanceMonitor;
