// @lifecycle canonical - Coordinates prompt hot reload workflows using the file observer + category manager.
/**
 * Hot Reload Manager Module
 * Orchestrates file system monitoring and reload workflows with event-driven architecture
 */
import * as path from 'node:path';
import { createFileObserver, } from './file-observer.js';
/**
 * Hot reload manager configuration
 */
const DEFAULT_HOT_RELOAD_CONFIG = {
    enabled: true,
    autoReload: true,
    reloadDelayMs: 1000,
    batchChanges: true,
    batchTimeoutMs: 2000,
    debounceMs: 500,
    watchPromptFiles: true,
    watchConfigFiles: true,
    recursive: true,
    ignoredPatterns: [
        '**/.git/**',
        '**/node_modules/**',
        '**/.DS_Store',
        '**/Thumbs.db',
        '**/*.tmp',
        '**/*.temp',
        '**/dist/**',
        '**/*.log',
    ],
    maxRetries: 3,
    retryDelayMs: 1000,
    frameworkCapabilities: {
        enabled: false,
        frameworkAnalysis: false,
        performanceMonitoring: false,
        preWarmAnalysis: false,
        invalidateFrameworkCaches: false,
    },
};
/**
 * HotReloadManager class
 * Coordinates file watching and reload operations
 */
export class HotReloadManager {
    constructor(logger, categoryManager, config, configManager) {
        this.auxiliaryReloads = [];
        this.isStarted = false;
        this.pendingChanges = [];
        this.watchedDirectories = new Set();
        this.logger = logger;
        this.categoryManager = categoryManager;
        this.config = { ...DEFAULT_HOT_RELOAD_CONFIG, ...config };
        // Create file observer with filtered config
        const observerConfig = {
            enabled: this.config.enabled,
            debounceMs: this.config.debounceMs,
            watchPromptFiles: this.config.watchPromptFiles,
            watchConfigFiles: this.config.watchConfigFiles,
            recursive: this.config.recursive,
            ignoredPatterns: this.config.ignoredPatterns,
            maxRetries: this.config.maxRetries,
            retryDelayMs: this.config.retryDelayMs,
        };
        this.fileObserver = createFileObserver(logger, observerConfig, configManager);
        this.stats = {
            reloadsTriggered: 0,
            filesChanged: 0,
            autoReloadsEnabled: this.config.autoReload,
            fileObserverStats: this.fileObserver.getStats(),
            frameworkReloads: 0,
            frameworkCacheClears: 0,
            performanceOptimizations: 0,
        };
        this.setupFileObserverEventHandlers();
    }
    /**
     * Start hot reload monitoring
     */
    async start() {
        if (this.isStarted) {
            this.logger.warn('HotReloadManager is already started');
            return;
        }
        if (!this.config.enabled) {
            this.logger.info('HotReloadManager is disabled in configuration');
            return;
        }
        this.logger.info('üî• HotReloadManager: Starting hot reload monitoring...');
        await this.fileObserver.start();
        this.isStarted = true;
        this.logger.info(`‚úÖ HotReloadManager started - Auto reload: ${this.config.autoReload ? 'ON' : 'OFF'}`);
    }
    /**
     * Stop hot reload monitoring
     */
    async stop() {
        if (!this.isStarted) {
            return;
        }
        this.logger.info('üõë HotReloadManager: Stopping hot reload monitoring...');
        // Clear batch timer
        if (this.batchTimer) {
            clearTimeout(this.batchTimer);
            this.batchTimer = undefined;
        }
        await this.fileObserver.stop();
        this.isStarted = false;
        this.logger.info('‚úÖ HotReloadManager stopped');
    }
    /**
     * Set the callback for reload events
     */
    setReloadCallback(callback) {
        this.onReloadCallback = callback;
        this.logger.debug('HotReloadManager: Reload callback registered');
    }
    /**
     * Set the callback for methodology reload events
     * This callback is invoked when methodology YAML files change
     */
    setMethodologyReloadCallback(callback) {
        this.onMethodologyReloadCallback = callback;
        this.logger.debug('HotReloadManager: Methodology reload callback registered');
    }
    /**
     * Register auxiliary reload handlers (e.g., methodology, gate) with their watch directories.
     * Directories must also be passed to watchDirectories by the caller.
     */
    setAuxiliaryReloads(reloads) {
        this.auxiliaryReloads = reloads.map((reload) => ({
            ...reload,
            directories: reload.directories.map((dir) => path.normalize(dir)),
        }));
        this.logger.debug('HotReloadManager: Auxiliary reload handlers registered', {
            count: this.auxiliaryReloads.length,
            ids: this.auxiliaryReloads.map((r) => r.id),
        });
    }
    /**
     * Add directories to watch
     */
    async watchDirectories(directories) {
        if (!this.isStarted) {
            throw new Error('HotReloadManager must be started before watching directories');
        }
        for (const { path: dirPath, category } of directories) {
            try {
                await this.fileObserver.watchDirectory(dirPath, category);
                this.watchedDirectories.add(dirPath);
                this.logger.info(`üìÅ HotReloadManager: Watching directory: ${dirPath}${category ? ` (${category})` : ''}`);
            }
            catch (error) {
                this.logger.error(`Failed to watch directory ${dirPath}:`, error);
            }
        }
    }
    /**
     * Manually trigger a reload
     */
    async triggerReload(reason = 'Manual trigger', requiresFullReload = true) {
        const event = {
            type: 'reload_required',
            reason,
            affectedFiles: [],
            timestamp: Date.now(),
            requiresFullReload,
        };
        await this.processReloadEvent(event);
    }
    /**
     * Setup file observer event handlers
     */
    setupFileObserverEventHandlers() {
        this.fileObserver.on('fileChange', (event) => {
            this.handleFileChange(event);
        });
        this.fileObserver.on('methodologyFileChange', (event) => {
            this.handleMethodologyFileChange(event);
        });
        this.fileObserver.on('watcherError', (error) => {
            this.logger.error(`File watcher error for ${error.directoryPath}:`, error.error);
        });
        this.logger.debug('HotReloadManager: File observer event handlers registered');
    }
    /**
     * Handle file change events
     */
    handleFileChange(event) {
        this.stats.filesChanged++;
        this.logger.debug(`File change detected: ${event.type} - ${event.filename}`);
        // Fire auxiliary reload handlers opportunistically (non-blocking)
        void this.triggerAuxiliaryReloads(event);
        if (this.config.batchChanges) {
            this.batchFileChange(event);
        }
        else {
            this.processFileChangeImmediate(event);
        }
    }
    /**
     * Handle methodology file change events
     * These are processed separately from regular file changes to enable
     * targeted methodology reload without affecting prompt system
     */
    async handleMethodologyFileChange(event) {
        this.stats.filesChanged++;
        const methodologyId = event.methodologyId ?? this.extractMethodologyId(event.filePath);
        this.logger.info(`üîß Methodology file change detected: ${event.type} - ${event.filename}` +
            (methodologyId ? ` (methodology: ${methodologyId})` : ''));
        const hotReloadEvent = {
            type: 'methodology_changed',
            reason: `Methodology file ${event.type}: ${event.filename}`,
            affectedFiles: [event.filePath],
            methodologyId,
            timestamp: event.timestamp,
            requiresFullReload: false, // Methodology changes typically don't need full reload
        };
        // Use dedicated methodology callback if available, otherwise fall through to general reload
        if (this.onMethodologyReloadCallback) {
            try {
                await this.onMethodologyReloadCallback(hotReloadEvent);
                this.logger.info(`‚úÖ Methodology ${methodologyId ?? 'unknown'} reloaded successfully`);
            }
            catch (error) {
                this.logger.error(`‚ùå Failed to reload methodology ${methodologyId ?? 'unknown'}:`, error);
            }
        }
        else {
            // Fallback to regular reload processing
            await this.processReloadEvent(hotReloadEvent);
        }
    }
    /**
     * Extract methodology ID from file path
     */
    extractMethodologyId(filePath) {
        const normalizedPath = filePath.replace(/\\/g, '/');
        const match = normalizedPath.match(/\/methodologies\/([^/]+)\//);
        return match?.[1]?.toLowerCase();
    }
    async triggerAuxiliaryReloads(event) {
        if (this.auxiliaryReloads.length === 0) {
            return;
        }
        const normalizedPath = path.normalize(event.filePath);
        for (const reload of this.auxiliaryReloads) {
            const matchesPath = reload.directories.some((dir) => normalizedPath.startsWith(path.normalize(dir)));
            const matchesCustom = reload.match ? reload.match(event) : true;
            if (!matchesPath || !matchesCustom) {
                continue;
            }
            const hotReloadEvent = {
                type: 'reload_required',
                reason: `${reload.id} file ${event.type}: ${event.filename}`,
                affectedFiles: [event.filePath],
                timestamp: event.timestamp,
                requiresFullReload: false,
            };
            try {
                await reload.handler(hotReloadEvent);
            }
            catch (error) {
                this.logger.error(`[HotReloadManager] Auxiliary reload failed for ${reload.id}`, error);
            }
        }
    }
    /**
     * Batch file changes to prevent excessive reloads
     */
    batchFileChange(event) {
        this.pendingChanges.push(event);
        // Clear existing timer
        if (this.batchTimer) {
            clearTimeout(this.batchTimer);
        }
        // Set new timer
        this.batchTimer = setTimeout(() => {
            this.processBatchedChanges();
        }, this.config.batchTimeoutMs);
    }
    /**
     * Process batched file changes
     */
    async processBatchedChanges() {
        if (this.pendingChanges.length === 0) {
            return;
        }
        const changes = [...this.pendingChanges];
        this.pendingChanges = [];
        this.batchTimer = undefined;
        this.logger.info(`Processing ${changes.length} batched file changes`);
        // Group changes by type
        const promptChanges = changes.filter((c) => c.isPromptFile);
        const configChanges = changes.filter((c) => c.isConfigFile);
        // Determine reload type
        const requiresFullReload = configChanges.length > 0 ||
            promptChanges.some((c) => c.type === 'added' || c.type === 'removed');
        let reloadType = 'prompt_changed';
        let reason = `${promptChanges.length} prompt file(s) changed`;
        if (configChanges.length > 0) {
            reloadType = 'config_changed';
            reason = `${configChanges.length} config file(s) changed`;
        }
        const hotReloadEvent = {
            type: reloadType,
            reason,
            affectedFiles: changes.map((c) => c.filePath),
            timestamp: Date.now(),
            requiresFullReload,
        };
        await this.processReloadEvent(hotReloadEvent);
    }
    /**
     * Process immediate file change (no batching)
     */
    async processFileChangeImmediate(event) {
        let reloadType = 'prompt_changed';
        let requiresFullReload = false;
        if (event.isConfigFile) {
            reloadType = 'config_changed';
            requiresFullReload = true;
        }
        else if (event.type === 'added' || event.type === 'removed') {
            requiresFullReload = true;
        }
        const hotReloadEvent = {
            type: reloadType,
            reason: `File ${event.type}: ${event.filename}`,
            affectedFiles: [event.filePath],
            category: event.category,
            timestamp: event.timestamp,
            requiresFullReload,
        };
        await this.processReloadEvent(hotReloadEvent);
    }
    /**
     * Process reload event with framework integration
     */
    async processReloadEvent(event) {
        this.stats.reloadsTriggered++;
        this.stats.lastReloadTime = event.timestamp;
        this.logger.info(`üîÑ Hot reload triggered: ${event.reason}`);
        // Framework-aware pre-processing
        if (this.config.frameworkCapabilities?.enabled) {
            await this.processFrameworkPreReload(event);
        }
        if (this.config.autoReload && this.onReloadCallback) {
            try {
                // Add delay if configured
                if (this.config.reloadDelayMs > 0) {
                    this.logger.debug(`Delaying reload by ${this.config.reloadDelayMs}ms`);
                    await new Promise((resolve) => setTimeout(resolve, this.config.reloadDelayMs));
                }
                await this.onReloadCallback(event);
                // Framework-aware post-processing
                if (this.config.frameworkCapabilities?.enabled) {
                    await this.processFrameworkPostReload(event);
                }
                this.logger.info('‚úÖ Hot reload completed successfully');
            }
            catch (error) {
                this.logger.error('‚ùå Hot reload failed:', error);
            }
        }
        else {
            this.logger.info('‚è≠Ô∏è Auto reload is disabled - skipping automatic reload');
        }
    }
    /**
     * Get current statistics
     */
    getStats() {
        return {
            ...this.stats,
            fileObserverStats: this.fileObserver.getStats(),
        };
    }
    /**
     * Get current configuration
     */
    getConfig() {
        return { ...this.config };
    }
    /**
     * Update configuration
     */
    updateConfig(newConfig) {
        const oldAutoReload = this.config.autoReload;
        this.config = { ...this.config, ...newConfig };
        // Update file observer config if needed
        if (newConfig.debounceMs !== undefined ||
            newConfig.watchPromptFiles !== undefined ||
            newConfig.watchConfigFiles !== undefined) {
            this.fileObserver.updateConfig({
                debounceMs: this.config.debounceMs,
                watchPromptFiles: this.config.watchPromptFiles,
                watchConfigFiles: this.config.watchConfigFiles,
            });
        }
        if (oldAutoReload !== this.config.autoReload) {
            this.stats.autoReloadsEnabled = this.config.autoReload;
            this.logger.info(`Auto reload ${this.config.autoReload ? 'enabled' : 'disabled'}`);
        }
        this.logger.info('HotReloadManager configuration updated');
    }
    /**
     * Check if hot reload manager is running
     */
    isRunning() {
        return this.isStarted;
    }
    /**
     * Get watched directories
     */
    getWatchedDirectories() {
        return Array.from(this.watchedDirectories);
    }
    /**
     * Framework pre-reload processing
     *  Basic framework cache invalidation and analysis
     */
    async processFrameworkPreReload(event) {
        const startTime = performance.now();
        this.logger.debug('Processing framework pre-reload analysis...');
        if (this.config.frameworkCapabilities?.invalidateFrameworkCaches) {
            this.stats.frameworkCacheClears++;
            this.logger.debug('Framework caches invalidated for hot-reload');
        }
        if (this.config.frameworkCapabilities?.frameworkAnalysis) {
            this.stats.frameworkReloads++;
            this.logger.debug(`Framework analysis prepared for ${event.affectedFiles.length} files`);
        }
        const processingTime = performance.now() - startTime;
        this.logger.debug(`Framework pre-reload completed in ${processingTime.toFixed(2)}ms`);
    }
    /**
     * Framework post-reload processing
     *  Basic performance optimization and cache warming
     */
    async processFrameworkPostReload(event) {
        const startTime = performance.now();
        this.logger.debug('Processing framework post-reload optimizations...');
        if (this.config.frameworkCapabilities?.preWarmAnalysis) {
            this.stats.performanceOptimizations++;
            this.logger.debug('Framework analysis cache pre-warmed');
        }
        if (this.config.frameworkCapabilities?.performanceMonitoring) {
            const processingTime = performance.now() - startTime;
            this.logger.debug(`Framework post-reload monitoring: ${processingTime.toFixed(2)}ms`);
        }
    }
    /**
     * Enable framework capabilities
     */
    enableFrameworkCapabilities(options = {}) {
        this.config.frameworkCapabilities = {
            enabled: true,
            frameworkAnalysis: true,
            performanceMonitoring: true,
            preWarmAnalysis: true,
            invalidateFrameworkCaches: true,
            ...options,
        };
        // Enable framework integration on file observer if available
        if ('enableFrameworkIntegration' in this.fileObserver) {
            this.fileObserver.enableFrameworkIntegration({
                enabled: true,
                analyzeChanges: this.config.frameworkCapabilities.frameworkAnalysis,
                cacheInvalidation: this.config.frameworkCapabilities.invalidateFrameworkCaches,
                performanceTracking: this.config.frameworkCapabilities.performanceMonitoring,
            });
        }
        this.logger.info('Framework capabilities enabled for HotReloadManager');
    }
    /**
     * Disable framework capabilities
     */
    disableFrameworkCapabilities() {
        this.config.frameworkCapabilities = {
            enabled: false,
            frameworkAnalysis: false,
            performanceMonitoring: false,
            preWarmAnalysis: false,
            invalidateFrameworkCaches: false,
        };
        // Disable framework integration on file observer if available
        if ('disableFrameworkIntegration' in this.fileObserver) {
            this.fileObserver.disableFrameworkIntegration();
        }
        this.logger.info('Framework capabilities disabled for HotReloadManager');
    }
    /**
     * Check if framework capabilities are enabled
     */
    isFrameworkCapabilitiesEnabled() {
        return this.config.frameworkCapabilities?.enabled ?? false;
    }
    /**
     * Get debug information
     */
    getDebugInfo() {
        return {
            isRunning: this.isRunning(),
            config: this.getConfig(),
            stats: this.getStats(),
            watchedDirectories: this.getWatchedDirectories(),
            pendingChanges: this.pendingChanges.length,
            fileObserverDebug: this.fileObserver.getDebugInfo(),
            frameworkCapabilities: this.config.frameworkCapabilities,
        };
    }
}
/**
 * Factory function to create a HotReloadManager instance
 */
export function createHotReloadManager(logger, categoryManager, config, configManager) {
    return new HotReloadManager(logger, categoryManager, config, configManager);
}
//# sourceMappingURL=hot-reload-manager.js.map