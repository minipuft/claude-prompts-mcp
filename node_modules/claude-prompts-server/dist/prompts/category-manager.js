// @lifecycle canonical - Manages prompt category metadata, validation, and analytics.
/**
 * Category Manager Module
 * Handles category management logic with validation, organization, and relationship tracking
 */
/**
 * CategoryManager class
 * Centralizes all category-related operations with validation and consistency checking
 */
export class CategoryManager {
    constructor(logger) {
        this.categories = [];
        this.logger = logger;
    }
    /**
     * Load and validate categories from configuration
     */
    async loadCategories(categories) {
        this.logger.debug(`CategoryManager: Loading ${categories.length} categories`);
        const result = {
            isValid: true,
            issues: [],
            warnings: [],
        };
        // Validate categories
        const validatedCategories = [];
        const seenIds = new Set();
        const seenNames = new Set();
        for (let i = 0; i < categories.length; i++) {
            const category = categories[i];
            // Validate required fields
            if (!category.id || typeof category.id !== 'string') {
                result.issues.push(`Category ${i + 1}: Missing or invalid 'id' field`);
                result.isValid = false;
                continue;
            }
            if (!category.name || typeof category.name !== 'string') {
                result.issues.push(`Category ${i + 1} (${category.id}): Missing or invalid 'name' field`);
                result.isValid = false;
                continue;
            }
            if (!category.description || typeof category.description !== 'string') {
                result.warnings.push(`Category ${category.id}: Missing or empty description`);
            }
            // Check for duplicates
            if (seenIds.has(category.id)) {
                result.issues.push(`Duplicate category ID found: ${category.id}`);
                result.isValid = false;
                continue;
            }
            if (seenNames.has(category.name)) {
                result.warnings.push(`Duplicate category name found: ${category.name}`);
            }
            seenIds.add(category.id);
            seenNames.add(category.name);
            // Clean and normalize category
            const normalizedCategory = {
                id: category.id.trim(),
                name: category.name.trim(),
                description: (category.description || '').trim(),
                registerWithMcp: category.registerWithMcp,
            };
            validatedCategories.push(normalizedCategory);
        }
        this.categories = validatedCategories;
        this.logger.info(`CategoryManager: Loaded ${this.categories.length} valid categories`);
        if (result.issues.length > 0) {
            this.logger.error(`CategoryManager: ${result.issues.length} validation issues found`);
            result.issues.forEach((issue) => this.logger.error(`  - ${issue}`));
        }
        if (result.warnings.length > 0) {
            this.logger.warn(`CategoryManager: ${result.warnings.length} warnings found`);
            result.warnings.forEach((warning) => this.logger.warn(`  - ${warning}`));
        }
        return result;
    }
    /**
     * Get all categories
     */
    getCategories() {
        return [...this.categories];
    }
    /**
     * Get category by ID
     */
    getCategoryById(id) {
        return this.categories.find((cat) => cat.id === id);
    }
    /**
     * Get category by name
     */
    getCategoryByName(name) {
        return this.categories.find((cat) => cat.name === name);
    }
    /**
     * Validate that all prompt categories exist
     */
    validatePromptCategories(prompts) {
        const result = {
            isValid: true,
            issues: [],
            warnings: [],
        };
        const categoryIds = new Set(this.categories.map((cat) => cat.id));
        const usedCategories = new Set();
        for (const prompt of prompts) {
            if (!prompt.category) {
                result.issues.push(`Prompt '${prompt.id}' has no category assigned`);
                result.isValid = false;
                continue;
            }
            if (!categoryIds.has(prompt.category)) {
                result.issues.push(`Prompt '${prompt.id}' references non-existent category: ${prompt.category}`);
                result.isValid = false;
                continue;
            }
            usedCategories.add(prompt.category);
        }
        // Check for unused categories
        for (const category of this.categories) {
            if (!usedCategories.has(category.id)) {
                result.warnings.push(`Category '${category.id}' (${category.name}) has no prompts assigned`);
            }
        }
        return result;
    }
    /**
     * Get prompts by category
     */
    getPromptsByCategory(prompts, categoryId) {
        return prompts.filter((prompt) => prompt.category === categoryId);
    }
    /**
     * Get category statistics
     */
    getCategoryStatistics(prompts) {
        const categoryBreakdown = [];
        let totalPrompts = 0;
        for (const category of this.categories) {
            const categoryPrompts = this.getPromptsByCategory(prompts, category.id);
            const promptCount = categoryPrompts.length;
            categoryBreakdown.push({
                category,
                promptCount,
            });
            totalPrompts += promptCount;
        }
        const categoriesWithPrompts = categoryBreakdown.filter((item) => item.promptCount > 0).length;
        const emptyCategoriesCount = this.categories.length - categoriesWithPrompts;
        const averagePromptsPerCategory = this.categories.length > 0 ? totalPrompts / this.categories.length : 0;
        return {
            totalCategories: this.categories.length,
            categoriesWithPrompts,
            emptyCategoriesCount,
            averagePromptsPerCategory,
            categoryBreakdown,
        };
    }
    /**
     * Get category-prompt relationships
     */
    getCategoryPromptRelationships(prompts) {
        return this.categories.map((category) => {
            const categoryPrompts = this.getPromptsByCategory(prompts, category.id);
            return {
                categoryId: category.id,
                categoryName: category.name,
                promptIds: categoryPrompts.map((p) => p.id),
                promptCount: categoryPrompts.length,
                hasChains: categoryPrompts.some((p) => p.file && p.file.includes('chain')),
                hasTemplates: categoryPrompts.some((p) => p.file && p.file.includes('template')),
            };
        });
    }
    /**
     * Organize prompts by category for display
     */
    organizePromptsByCategory(prompts) {
        const organized = new Map();
        for (const category of this.categories) {
            const categoryPrompts = this.getPromptsByCategory(prompts, category.id);
            organized.set(category, categoryPrompts);
        }
        return organized;
    }
    /**
     * Check consistency between categories and prompts
     */
    checkConsistency(prompts) {
        const issues = [];
        const orphanedPrompts = [];
        const emptyCategories = [];
        const categoryIds = new Set(this.categories.map((cat) => cat.id));
        // Find orphaned prompts (prompts with invalid category references)
        for (const prompt of prompts) {
            if (prompt.category && !categoryIds.has(prompt.category)) {
                orphanedPrompts.push(prompt);
                issues.push(`Prompt '${prompt.id}' references non-existent category: ${prompt.category}`);
            }
        }
        // Find empty categories
        for (const category of this.categories) {
            const categoryPrompts = this.getPromptsByCategory(prompts, category.id);
            if (categoryPrompts.length === 0) {
                emptyCategories.push(category);
            }
        }
        const consistent = issues.length === 0 && orphanedPrompts.length === 0;
        return {
            consistent,
            issues,
            orphanedPrompts,
            emptyCategories,
        };
    }
    /**
     * Get debug information for troubleshooting
     */
    getDebugInfo(prompts) {
        const debugInfo = {
            categoriesLoaded: this.categories.length,
            categoryIds: this.categories.map((cat) => cat.id),
            categoryNames: this.categories.map((cat) => cat.name),
            statistics: prompts ? this.getCategoryStatistics(prompts) : undefined,
            consistency: prompts ? this.checkConsistency(prompts) : undefined,
        };
        return debugInfo;
    }
}
/**
 * Factory function to create a CategoryManager instance
 */
export function createCategoryManager(logger) {
    return new CategoryManager(logger);
}
//# sourceMappingURL=category-manager.js.map