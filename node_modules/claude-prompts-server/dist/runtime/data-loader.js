// @lifecycle canonical - Prompt data loading helper using shared context.
/**
 * Loads and converts prompts with path normalization and registration.
 * Reuses existing PromptAssetManager behavior without duplicating transport/config logic.
 */
import { access } from 'node:fs/promises';
import * as path from 'node:path';
export async function loadPromptData(params) {
    const { logger, configManager, promptManager, runtimeOptions, serverRoot } = params;
    const isVerbose = runtimeOptions.verbose;
    const isQuiet = runtimeOptions.quiet;
    // Resolve prompts file path
    const config = configManager.getConfig();
    let promptsFilePath = configManager.getResolvedPromptsFilePath();
    if (!isQuiet) {
        logger.info('Starting prompt loading pipeline...');
        logger.info(`Config prompts.file setting: "${config.prompts.file}"`);
    }
    if (process.env.MCP_PROMPTS_CONFIG_PATH) {
        logger.info(`ðŸŽ¯ MCP_PROMPTS_CONFIG_PATH override: "${process.env.MCP_PROMPTS_CONFIG_PATH}"`);
    }
    // Normalize to absolute path if needed
    if (!path.isAbsolute(promptsFilePath)) {
        const baseRoot = serverRoot ?? configManager.getServerRoot?.() ?? process.cwd();
        promptsFilePath = path.resolve(baseRoot, promptsFilePath);
        if (isVerbose) {
            logger.info(`ðŸ”§ Converting prompts path to absolute: ${promptsFilePath}`);
        }
    }
    // Verify file exists
    await access(promptsFilePath).catch((error) => {
        logger.error(`âœ— Prompts configuration file NOT FOUND: ${promptsFilePath}`);
        if (isVerbose) {
            logger.error(`File access error:`, error);
            logger.error(`Is path absolute? ${path.isAbsolute(promptsFilePath)}`);
            logger.error(`Normalized path: ${path.normalize(promptsFilePath)}`);
        }
        throw new Error(`Prompts configuration file not found: ${promptsFilePath}`);
    });
    if (isVerbose) {
        logger.info(`âœ“ Prompts configuration file exists: ${promptsFilePath}`);
    }
    const result = await promptManager.loadAndConvertPrompts(promptsFilePath, path.dirname(promptsFilePath));
    const promptsData = result.promptsData;
    const categories = result.categories;
    const convertedPrompts = result.convertedPrompts;
    if (!isQuiet) {
        logger.info('=== PROMPT LOADING RESULTS ===');
        logger.info(`âœ“ Loaded ${promptsData.length} prompts from ${categories.length} categories`);
        logger.info(`âœ“ Converted ${convertedPrompts.length} prompts to MCP format`);
    }
    // Update downstream managers if available
    params.mcpToolsManager?.updateData(promptsData, convertedPrompts, categories);
    params.apiManager?.updateData(promptsData, categories, convertedPrompts);
    // Register prompts with MCP server
    await promptManager.registerAllPrompts(convertedPrompts);
    if (!isQuiet) {
        logger.info('ðŸ”„ Prompts registered with MCP server');
    }
    return {
        promptsData,
        categories,
        convertedPrompts,
        promptsFilePath,
    };
}
//# sourceMappingURL=data-loader.js.map