/**
 * Consolidated Type Index for MCP Prompts Server
 *
 * This module serves as the central type export hub, importing from domain-specific
 * type files and re-exporting them for easy consumption. Types are now organized
 * by domain for better maintainability and reduced duplication.
 *
 * Architecture: Domain-specific types -> This index -> Consumer modules
 */
export type { McpToolRequest } from './execution.js';
export type { AnalysisConfig, AnalysisMode, BaseMessageContent, ChainSessionConfig, Config, FrameworksConfig, JudgeConfig, LLMIntegrationConfig, LLMProvider, LoggingConfig, Message, MessageContent, MessageRole, SemanticAnalysisConfig, ServerConfig, TextMessageContent, ToolDescriptionsOptions, TransportConfig, TransportsConfig, } from '../types.js';
export type { Category, CategoryPromptRelationship, CategoryPromptsResult, CategoryStatistics, CategoryValidationResult, PromptArgument, PromptData, PromptFile, PromptFileContent, PromptsConfig, PromptsConfigFile, PromptsFile, } from '../prompts/types.js';
export type { BaseExecutionContext, ChainExecutionResult, ChainExecutionState, ChainStep, ChainStepResult, ConvertedPrompt, EnhancedChainExecutionOptions, ExecutionModifier, ExecutionModifiers, ExecutionStats, ExecutionStrategy, ExecutionStrategyType, ExecutionType, PerformanceMetrics, TemplateContext, UnifiedExecutionResult, ValidationResult, } from '../execution/types.js';
import type { ChainStep, ChainStepResult, EnhancedChainExecutionOptions } from '../execution/types.js';
import type { GateStatus, StepResult } from '../gates/types.js';
export type { GateActivationResult, GateDefinition, GateEvaluationResult, GatePassCriteria, GateRequirement, GateRequirementType, GatesConfig, GateStatus, GateType, LightweightGateDefinition, StepResult, ValidationCheck, ValidationContext, } from '../gates/types.js';
export type { FrameworkDefinition, FrameworkExecutionContext, FrameworkMethodology, FrameworkSelectionCriteria, FrameworkStateInfo, FrameworkSwitchingConfig, IMethodologyGuide, IntegratedAnalysisResult, } from '../frameworks/types/index.js';
export interface ConversationHistoryItem {
    role: 'user' | 'assistant';
    content: string;
    timestamp: number;
    isProcessedTemplate?: boolean;
}
export interface EnhancedChainExecutionContext {
    chainId: string;
    chainName: string;
    startTime: number;
    executionOptions: EnhancedChainExecutionOptions;
    allSteps: ChainStep[];
    completedSteps: Set<string>;
    failedSteps: Set<string>;
    skippedSteps: Set<string>;
    stepResults: Record<string, StepResult>;
    executionPlan?: {
        executionOrder: string[];
        parallelGroups: Map<string, string[]>;
    };
    currentPhase: 'planning' | 'executing' | 'completed' | 'failed';
    activeParallelGroups: Map<string, string[]>;
    retryCount: Record<string, number>;
    gateValidationResults: Record<string, GateStatus[]>;
}
export interface ApiResponse {
    success: boolean;
    message: string;
    data?: unknown;
}
export interface ToolResponse {
    content: Array<{
        type: 'text';
        text: string;
    }>;
    isError?: boolean;
    structuredContent?: Record<string, any>;
}
export interface ToolParameter {
    description?: string;
    examples?: string[];
}
export interface ToolDescription {
    description: string;
    parameters?: Record<string, ToolParameter | string>;
    shortDescription?: string;
    category?: string;
    frameworkAware?: {
        enabled?: string;
        disabled?: string;
        parametersEnabled?: Record<string, ToolParameter | string>;
        parametersDisabled?: Record<string, ToolParameter | string>;
        methodologies?: Record<string, string>;
        methodologyParameters?: Record<string, Record<string, ToolParameter | string>>;
    };
}
export interface ToolDescriptionsConfig {
    version: string;
    lastUpdated?: string;
    tools: Record<string, ToolDescription>;
    activeFramework?: string;
    activeMethodology?: string;
    generatedFrom?: 'fallback' | 'legacy' | 'defaults' | string;
    generatedAt?: string;
}
export interface ServerRefreshOptions {
    restart?: boolean;
    reason?: string;
}
export interface ServerState {
    isStarted: boolean;
    transport: string;
    port?: number;
    startTime: number;
}
export interface FileOperation {
    (): Promise<boolean>;
}
export interface ModificationResult {
    success: boolean;
    message: string;
}
export interface ExpressRequest {
    body: any;
    params: Record<string, string>;
    headers: Record<string, string>;
    ip: string;
    method: string;
    url: string;
}
export interface ExpressResponse {
    json: (data: any) => void;
    status: (code: number) => ExpressResponse;
    send: (data: any) => void;
    setHeader: (name: string, value: string) => void;
    end: () => void;
    sendStatus: (code: number) => void;
    on: (event: string, callback: () => void) => void;
}
export interface ExecutionState {
    type: 'single' | 'chain';
    promptId: string;
    status: 'pending' | 'running' | 'waiting_gate' | 'completed' | 'failed' | 'retrying';
    currentStep?: number;
    totalSteps?: number;
    gates: GateStatus[];
    results: Record<string, string | ChainStepResult>;
    metadata: {
        startTime: number;
        endTime?: number;
        stepConfirmation?: boolean;
        gateValidation?: boolean;
        sessionId?: string;
    };
}
export interface EnhancedChainExecutionState {
    chainId: string;
    currentStepIndex: number;
    totalSteps: number;
    startTime: number;
    status: 'pending' | 'running' | 'waiting_gate' | 'completed' | 'failed';
    stepResults: Record<string, StepResult>;
    gates: Record<string, GateStatus>;
    executionMode: 'auto' | 'chain';
    gateValidation: boolean;
    stepConfirmation: boolean;
}
export interface ChainExecutionProgress {
    chainId: string;
    chainName: string;
    currentStep: number;
    totalSteps: number;
    status: 'pending' | 'running' | 'completed' | 'failed' | 'paused';
    steps: ChainStepProgress[];
    startTime: number;
    endTime?: number;
    duration?: number;
    errorCount: number;
    autoExecute: boolean;
}
export interface ChainStepProgress {
    stepIndex: number;
    stepName: string;
    promptId: string;
    status: 'pending' | 'running' | 'completed' | 'failed' | 'skipped';
    startTime?: number;
    endTime?: number;
    duration?: number;
    result?: string;
    error?: string;
    gateResults?: GateStatus[];
}
export interface AutoExecutionConfig {
    enabled: boolean;
    stepConfirmation: boolean;
    gateValidation: boolean;
    pauseOnError: boolean;
    maxRetries: number;
    retryDelay: number;
}
export declare const MAX_HISTORY_SIZE = 100;
export declare enum LogLevel {
    DEBUG = "DEBUG",
    INFO = "INFO",
    WARN = "WARN",
    ERROR = "ERROR"
}
export declare enum TransportType {
    STDIO = "stdio",
    SSE = "sse"
}
export declare enum StepStatus {
    PENDING = "pending",
    RUNNING = "running",
    COMPLETED = "completed",
    FAILED = "failed",
    SKIPPED = "skipped"
}
