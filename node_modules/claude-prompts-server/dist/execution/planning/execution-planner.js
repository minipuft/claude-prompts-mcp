// @lifecycle canonical - Plans operator execution order and dependencies.
import { CategoryExtractor, } from '../../mcp-tools/prompt-engine/utils/category-extractor.js';
/**
 * Determines execution strategy, complexity, and gate requirements for a command.
 * Extracted from PromptExecutionService to make planning reusable across the pipeline.
 */
export class ExecutionPlanner {
    constructor(semanticAnalyzer, logger) {
        this.semanticAnalyzer = semanticAnalyzer;
        this.logger = logger;
        /** Cached methodology gate IDs loaded from GateLoader */
        this.methodologyGateIdsCache = null;
        this.categoryExtractor = new CategoryExtractor(logger);
    }
    setFrameworkManager(manager) {
        this.frameworkManager = manager;
    }
    setGateLoader(loader) {
        this.gateLoader = loader;
        // Invalidate cache when loader changes
        this.methodologyGateIdsCache = null;
    }
    /**
     * Get methodology gate IDs dynamically from GateLoader.
     * Caches the result to avoid repeated disk reads.
     */
    async getMethodologyGateIds() {
        if (this.methodologyGateIdsCache) {
            return this.methodologyGateIdsCache;
        }
        if (!this.gateLoader) {
            this.logger.debug('[ExecutionPlanner] No GateLoader available for methodology gate detection');
            return new Set();
        }
        try {
            const ids = await this.gateLoader.getMethodologyGateIds();
            this.methodologyGateIdsCache = new Set(ids);
            return this.methodologyGateIdsCache;
        }
        catch (error) {
            this.logger.warn('[ExecutionPlanner] Failed to load methodology gate IDs', { error });
            return new Set();
        }
    }
    async createPlan(options) {
        const { parsedCommand, convertedPrompt, frameworkEnabled = false, gateOverrides } = options;
        let analysis = null;
        if (this.semanticAnalyzer) {
            try {
                analysis = await this.semanticAnalyzer.analyzePrompt(convertedPrompt);
            }
            catch (error) {
                this.logger.warn('[ExecutionPlanner] Semantic analysis failed', {
                    promptId: convertedPrompt.id,
                    error,
                });
            }
        }
        const categoryInfo = this.categoryExtractor.extractCategory(convertedPrompt);
        const strategyInfo = this.resolveStrategy({
            convertedPrompt,
            parsedCommand,
            analysis,
        });
        const modifierResolution = this.normalizeModifiers(parsedCommand?.modifier ?? strategyInfo.modifier, parsedCommand?.modifiers ?? strategyInfo.modifiers ?? convertedPrompt.executionModifiers);
        const explicitGates = this.collectExplicitGateIds(convertedPrompt, categoryInfo);
        const autoGates = this.shouldAutoAssignGates()
            ? this.autoAssignGates(categoryInfo.category)
            : [];
        const mergedGates = this.mergeGates(explicitGates, autoGates, [
            ...(categoryInfo.gateConfiguration?.exclude ?? []),
            ...this.getPromptLevelExcludes(convertedPrompt),
        ]);
        // Add string gate IDs from unified gates parameter
        if (gateOverrides?.gates?.length) {
            gateOverrides.gates.forEach((gate) => {
                if (typeof gate === 'string') {
                    mergedGates.add(gate);
                }
            });
        }
        // Filter methodology gates if framework_gates is explicitly disabled
        if (convertedPrompt.enhancedGateConfiguration?.framework_gates === false) {
            const methodologyGateIds = await this.getMethodologyGateIds();
            methodologyGateIds.forEach((gateId) => mergedGates.delete(gateId));
        }
        // Check for framework override from symbolic operators
        const hasFrameworkOverride = Boolean(parsedCommand?.executionPlan?.frameworkOverride ?? parsedCommand?.executionPlan);
        let requiresFramework = this.requiresFramework(strategyInfo.strategy, convertedPrompt, analysis, mergedGates, frameworkEnabled, hasFrameworkOverride);
        const adjusted = this.applyModifierOverrides(modifierResolution.modifiers, mergedGates, requiresFramework);
        requiresFramework = adjusted.requiresFramework;
        return {
            strategy: strategyInfo.strategy,
            gates: Array.from(adjusted.gates),
            requiresFramework,
            requiresSession: this.requiresSession(parsedCommand, convertedPrompt, strategyInfo.strategy),
            category: categoryInfo.category,
            modifier: modifierResolution.modifier,
            modifiers: modifierResolution.modifiers,
            semanticAnalysis: analysis ?? undefined,
        };
    }
    async createChainPlan(options) {
        const { parsedCommand, steps, frameworkEnabled = false, gateOverrides } = options;
        if (!Array.isArray(steps) || steps.length === 0) {
            throw new Error('Chain planning requires at least one step with a converted prompt');
        }
        const chainPrompt = parsedCommand.convertedPrompt ?? steps[0]?.convertedPrompt;
        if (!chainPrompt) {
            throw new Error('Chain planning requires a converted prompt on the command or first step');
        }
        const chainPlan = await this.createPlan({
            parsedCommand,
            convertedPrompt: chainPrompt,
            frameworkEnabled,
            gateOverrides,
        });
        const stepPlans = [];
        for (const step of steps) {
            if (!step?.convertedPrompt) {
                throw new Error(`Chain step ${step?.promptId ?? 'unknown'} missing converted prompt for planning`);
            }
            const stepPlan = await this.createPlan({
                parsedCommand,
                convertedPrompt: step.convertedPrompt,
                frameworkEnabled,
                gateOverrides,
            });
            stepPlans.push(stepPlan);
        }
        return {
            chainPlan,
            stepPlans,
        };
    }
    resolveStrategy(params) {
        const { convertedPrompt, parsedCommand, analysis } = params;
        if (this.hasChainIndicators(parsedCommand, convertedPrompt, analysis)) {
            return { strategy: 'chain' };
        }
        if (analysis?.executionType === 'chain') {
            return { strategy: 'chain' };
        }
        if (analysis?.executionType === 'single') {
            return { strategy: 'single' };
        }
        return this.heuristicResolution(convertedPrompt);
    }
    hasChainIndicators(parsedCommand, prompt, analysis) {
        if (prompt?.chainSteps?.length) {
            return true;
        }
        if (parsedCommand?.commandType === 'chain') {
            return true;
        }
        const hasChainOperator = parsedCommand?.operators?.operators?.some((op) => op.type === 'chain');
        if (hasChainOperator) {
            return true;
        }
        if (analysis?.executionType === 'chain') {
            return true;
        }
        if (analysis?.executionCharacteristics?.hasChainSteps) {
            return true;
        }
        return false;
    }
    heuristicResolution(prompt) {
        if (prompt.chainSteps?.length) {
            return { strategy: 'chain' };
        }
        const hasSystemMessage = Boolean(prompt.systemMessage?.trim());
        const hasTemplateVars = /\{\{.*?\}\}/.test(prompt.userMessageTemplate ?? '');
        const hasComplexLogic = /{%-|{%\s*if|{%\s*for/.test(prompt.userMessageTemplate ?? '');
        // All single prompts resolve to 'single' strategy (formerly 'prompt' or 'template')
        return { strategy: 'single' };
    }
    normalizeModifiers(modifier, modifiers) {
        const normalizedModifier = modifier ?? this.extractModifierFromFlags(modifiers);
        const normalizedModifiers = normalizedModifier !== undefined
            ? this.buildModifiers(normalizedModifier)
            : modifiers
                ? this.stripModifierFlags(modifiers)
                : undefined;
        return {
            modifier: normalizedModifier,
            modifiers: normalizedModifiers,
        };
    }
    buildModifiers(modifier) {
        return {
            clean: modifier === 'clean',
            guided: modifier === 'guided',
            lean: modifier === 'lean',
            framework: modifier === 'framework',
        };
    }
    stripModifierFlags(modifiers) {
        return {
            clean: modifiers.clean === true,
            guided: modifiers.guided === true,
            lean: modifiers.lean === true,
            framework: modifiers.framework === true,
        };
    }
    extractModifierFromFlags(modifiers) {
        if (!modifiers) {
            return undefined;
        }
        const enabled = [];
        if (modifiers.clean)
            enabled.push('clean');
        if (modifiers.guided)
            enabled.push('guided');
        if (modifiers.lean)
            enabled.push('lean');
        if (modifiers.framework)
            enabled.push('framework');
        if (enabled.length > 1) {
            this.logger.warn('[ExecutionPlanner] Multiple execution modifiers detected; using the first match', {
                modifiers: enabled,
            });
        }
        return enabled[0];
    }
    applyModifierOverrides(modifiers, gates, requiresFramework) {
        if (!modifiers) {
            return { gates, requiresFramework };
        }
        const normalized = this.stripModifierFlags(modifiers);
        if (normalized.clean) {
            gates.clear();
            return { gates, requiresFramework: false };
        }
        if (normalized.framework) {
            gates.clear();
            return { gates, requiresFramework: true };
        }
        if (normalized.lean) {
            return { gates, requiresFramework: false };
        }
        if (normalized.guided) {
            return { gates, requiresFramework: true };
        }
        return { gates, requiresFramework };
    }
    /**
     * Determines whether gates should be auto-assigned based on category.
     * Gates are always auto-assigned when appropriate for the prompt category.
     *
     * Note: The semantic layer (LLM integration) controls whether the SERVER validates gates,
     * not whether gates are assigned. Gate instructions are always rendered so the LLM client
     * can self-validate when server-side validation is disabled.
     *
     * Explicit gates from user/prompt configuration are always honored.
     */
    shouldAutoAssignGates() {
        // Gates should always be auto-assigned based on category
        // Server-side validation is controlled separately by semantic layer config
        return true;
    }
    autoAssignGates(category) {
        const gates = new Set(['framework-compliance']);
        const normalizedCategory = category?.toLowerCase() ?? 'general';
        switch (normalizedCategory) {
            case 'code_generation':
            case 'development':
                gates.add('code-quality');
                gates.add('technical-accuracy');
                break;
            case 'analysis':
            case 'research':
                gates.add('research-quality');
                gates.add('technical-accuracy');
                break;
            case 'documentation':
                gates.add('content-structure');
                gates.add('educational-clarity');
                break;
            case 'architecture':
                gates.add('technical-accuracy');
                gates.add('security-awareness');
                break;
            default:
                break;
        }
        return Array.from(gates);
    }
    collectExplicitGateIds(prompt, categoryInfo) {
        const gateIds = new Set();
        const addGate = (gateId) => {
            if (gateId && gateId.trim().length > 0) {
                gateIds.add(gateId.trim());
            }
        };
        (prompt.gates || []).forEach((gate) => addGate(gate.id || gate.name));
        prompt.autoAssignedGates?.forEach?.((gate) => addGate(gate?.id));
        this.getPromptLevelIncludes(prompt).forEach(addGate);
        (categoryInfo.gateConfiguration?.include || []).forEach(addGate);
        return gateIds;
    }
    getPromptLevelIncludes(prompt) {
        const includes = [];
        const gateConfig = prompt.gateConfiguration;
        if (gateConfig?.include) {
            includes.push(...gateConfig.include);
        }
        if (prompt.enhancedGateConfiguration?.include) {
            includes.push(...prompt.enhancedGateConfiguration.include);
        }
        return includes;
    }
    getPromptLevelExcludes(prompt) {
        const excludes = [];
        const gateConfig = prompt.gateConfiguration;
        if (gateConfig?.exclude) {
            excludes.push(...gateConfig.exclude);
        }
        if (prompt.enhancedGateConfiguration?.exclude) {
            excludes.push(...prompt.enhancedGateConfiguration.exclude);
        }
        return excludes;
    }
    mergeGates(explicitGates, autoAssigned, exclude) {
        const merged = new Set(explicitGates);
        autoAssigned.forEach((gate) => {
            if (gate)
                merged.add(gate);
        });
        exclude.forEach((gateId) => merged.delete(gateId));
        return merged;
    }
    requiresFramework(strategy, prompt, analysis, gates, frameworkEnabled, hasFrameworkOverride) {
        // Framework context required when:
        // . Enabled in config (normal framework resolution)
        // . Framework override detected from symbolic operator (@)
        // This supports BOTH system prompt injection AND gate filtering
        return frameworkEnabled || hasFrameworkOverride;
    }
    requiresSession(parsedCommand, prompt, strategy) {
        if (strategy === 'chain') {
            return true;
        }
        if (prompt.chainSteps?.length) {
            return true;
        }
        // Check for any operator that requires session state (chain, gate)
        const hasSessionOperator = parsedCommand?.operators?.operators?.some((op) => op.type === 'chain' || op.type === 'gate') ?? false;
        if (hasSessionOperator) {
            return true;
        }
        return false;
    }
}
//# sourceMappingURL=execution-planner.js.map