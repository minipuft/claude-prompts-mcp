// @lifecycle canonical - Enriches prompts with gate instructions prior to execution.
import { formatCriteriaAsGuidance } from '../criteria-guidance.js';
import { BasePipelineStage } from '../stage.js';
/**
 * Pipeline Stage 5: Gate Enhancement
 *
 * Renders gate guidance instructions and footer text for quality validation,
 * applying framework-specific and temporary gate criteria to prompts.
 *
 * Dependencies: context.executionPlan, context.convertedPrompt or context.parsedCommand.steps
 * Output: Enhanced prompts with gate instructions, context.activeGateIds
 * Can Early Exit: No
 */
export class GateEnhancementStage extends BasePipelineStage {
    constructor(gateService, temporaryGateRegistry, frameworksConfigProvider, gateReferenceResolver, frameworkManagerProvider, logger, metricsProvider, gatesConfigProvider, gateLoader) {
        super(logger);
        this.gateService = gateService;
        this.temporaryGateRegistry = temporaryGateRegistry;
        this.frameworksConfigProvider = frameworksConfigProvider;
        this.gateReferenceResolver = gateReferenceResolver;
        this.frameworkManagerProvider = frameworkManagerProvider;
        this.gateLoader = gateLoader;
        this.name = 'GateEnhancement';
        /** Cached methodology gate IDs loaded from GateLoader */
        this.methodologyGateIdsCache = null;
        this.metricsProvider = metricsProvider;
        this.gatesConfigProvider = gatesConfigProvider;
    }
    /**
     * Get methodology gate IDs dynamically from GateLoader.
     * Caches the result to avoid repeated disk reads.
     */
    async getMethodologyGateIds() {
        if (this.methodologyGateIdsCache) {
            return this.methodologyGateIdsCache;
        }
        if (!this.gateLoader) {
            this.logger.debug('[GateEnhancementStage] No GateLoader available for methodology gate detection');
            return new Set();
        }
        try {
            const ids = await this.gateLoader.getMethodologyGateIds();
            this.methodologyGateIdsCache = new Set(ids);
            return this.methodologyGateIdsCache;
        }
        catch (error) {
            this.logger.warn('[GateEnhancementStage] Failed to load methodology gate IDs', { error });
            return new Set();
        }
    }
    /**
     * Check if a gate ID is a methodology gate (synchronous check using cache).
     */
    isMethodologyGate(gateId) {
        return this.methodologyGateIdsCache?.has(gateId) ?? false;
    }
    /**
     * Returns gate service with validation.
     * This method should only be called after the null check in execute().
     */
    requireGateService() {
        if (this.gateService === null) {
            throw new Error('Gate service not available');
        }
        return this.gateService;
    }
    /**
     * Type-safe resolution of gate enhancement context using type guards.
     * Eliminates runtime errors by using compile-time type narrowing.
     */
    resolveGateContext(context) {
        // Chain execution context
        if (context.hasChainCommand()) {
            return {
                type: 'chain',
                steps: context.parsedCommand.steps,
            };
        }
        // Legacy compatibility: fallback for non-chain commands with steps
        if (context.parsedCommand?.steps !== undefined && context.parsedCommand.steps.length > 0) {
            return {
                type: 'chain',
                steps: context.parsedCommand.steps,
            };
        }
        // Single prompt execution context
        if (context.hasSinglePromptCommand()) {
            return {
                type: 'single',
                prompt: context.parsedCommand.convertedPrompt,
                inlineGateIds: context.parsedCommand.inlineGateIds ?? [],
            };
        }
        // Fallback for non-type-guarded single prompts
        if (context.parsedCommand?.convertedPrompt !== undefined) {
            return {
                type: 'single',
                prompt: context.parsedCommand.convertedPrompt,
                inlineGateIds: context.parsedCommand.inlineGateIds ?? [],
            };
        }
        return null;
    }
    /**
     * Add gates to the context accumulator from a specific source.
     * This replaces direct array manipulation with tracked provenance.
     */
    addGatesToAccumulator(context, gateIds, source) {
        if (!gateIds || gateIds.length === 0) {
            return;
        }
        const added = context.gates.addAll(gateIds, source);
        if (added > 0) {
            this.logger.debug('[GateEnhancementStage] Added gates to accumulator', {
                source,
                added,
                total: context.gates.size,
            });
        }
    }
    shouldSkipGateEnhancement(modifiers) {
        if (!modifiers) {
            return false;
        }
        return modifiers.clean === true || modifiers.framework === true;
    }
    /**
     * Get the active framework ID from context using FrameworkDecisionAuthority.
     * This ensures consistent framework resolution across all pipeline stages.
     *
     * Priority (handled by authority):
     * 1. Modifiers (%clean, %lean) - disable framework (returns undefined)
     * 2. @ operator override - explicit user intent
     * 3. Client selection from judge phase - user chose
     * 4. Global active framework - system default
     */
    getActiveFrameworkId(context) {
        const decisionInput = this.buildDecisionInput(context);
        const frameworkId = context.frameworkAuthority.getFrameworkId(decisionInput);
        const decision = context.frameworkAuthority.getCachedDecision();
        this.logger.debug('[GateEnhancementStage] getActiveFrameworkId', {
            frameworkId,
            decision: decision
                ? {
                    shouldApply: decision.shouldApply,
                    frameworkId: decision.frameworkId,
                    reason: decision.reason,
                    source: decision.source,
                }
                : null,
        });
        return frameworkId;
    }
    /**
     * Ensure methodology validation gate is present when frameworks are active
     */
    ensureDefaultMethodologyGate(gateIds, frameworksConfig, activeFrameworkId) {
        this.logger.debug('[GateEnhancementStage] ensureDefaultMethodologyGate', {
            inputGateCount: gateIds.length,
            enableMethodologyGates: frameworksConfig?.enableMethodologyGates,
            activeFrameworkId,
        });
        if (!frameworksConfig?.enableMethodologyGates || !activeFrameworkId) {
            this.logger.debug('[GateEnhancementStage] ensureDefaultMethodologyGate - skipped', {
                reason: !frameworksConfig?.enableMethodologyGates
                    ? 'enableMethodologyGates is false or undefined'
                    : 'activeFrameworkId is undefined',
            });
            return gateIds;
        }
        const hasMethodologyGate = gateIds.some((gate) => this.isMethodologyGate(gate));
        if (hasMethodologyGate) {
            this.logger.debug('[GateEnhancementStage] ensureDefaultMethodologyGate - already has', {
                existingGate: gateIds.find((gate) => this.isMethodologyGate(gate)),
            });
            return gateIds;
        }
        this.logger.debug('[GateEnhancementStage] ensureDefaultMethodologyGate - adding methodology-validation');
        return [...gateIds, 'methodology-validation'];
    }
    /**
     * Build decision input from context for FrameworkDecisionAuthority.
     * This extracts all relevant data for the centralized framework decision.
     */
    buildDecisionInput(context) {
        // Get global active framework from multiple sources:
        // 1. context.frameworkContext (set by FrameworkStage, may not exist yet)
        // 2. frameworkManager.selectFramework() (direct query to framework state)
        let globalActiveFramework = context.frameworkContext?.selectedFramework?.id;
        this.logger.debug('[GateEnhancementStage] buildDecisionInput - initial', {
            fromContext: globalActiveFramework,
            hasFrameworkContext: Boolean(context.frameworkContext),
        });
        const frameworkManager = this.frameworkManagerProvider();
        this.logger.debug('[GateEnhancementStage] buildDecisionInput - frameworkManager', {
            hasFrameworkManager: Boolean(frameworkManager),
            isInitialized: frameworkManager?.isInitialized,
        });
        if (!globalActiveFramework && frameworkManager) {
            try {
                // Query framework manager for the current active framework
                const activeFramework = frameworkManager.selectFramework({});
                globalActiveFramework = activeFramework?.id;
                this.logger.debug('[GateEnhancementStage] buildDecisionInput - selected', {
                    selectedId: activeFramework?.id,
                    selectedName: activeFramework?.name,
                });
            }
            catch (error) {
                // Framework manager may not be initialized, log the error
                this.logger.warn('[GateEnhancementStage] buildDecisionInput - selectFramework failed', {
                    error: error instanceof Error ? error.message : String(error),
                });
            }
        }
        const result = {
            modifiers: context.executionPlan?.modifiers,
            operatorOverride: context.parsedCommand?.executionPlan?.frameworkOverride,
            clientOverride: context.state.framework.clientOverride,
            globalActiveFramework,
        };
        this.logger.debug('[GateEnhancementStage] buildDecisionInput - result', result);
        return result;
    }
    async execute(context) {
        this.logEntry(context);
        if (this.gateService === null) {
            this.logExit({ skipped: 'Gate service unavailable' });
            return;
        }
        const gatesConfig = this.gatesConfigProvider?.();
        if (gatesConfig && gatesConfig.enabled === false) {
            this.logExit({ skipped: 'Gate system disabled by configuration' });
            return;
        }
        const executionPlan = context.executionPlan;
        if (executionPlan === undefined) {
            this.logExit({ skipped: 'Execution plan missing' });
            return;
        }
        if (this.shouldSkipGateEnhancement(executionPlan.modifiers)) {
            this.logExit({ skipped: 'Gate enhancement disabled by execution modifier' });
            return;
        }
        const frameworksConfig = this.frameworksConfigProvider?.();
        // Initialize methodology gate IDs cache for dynamic filtering
        await this.getMethodologyGateIds();
        const registeredGates = await this.registerTemporaryGates(context);
        // Type-safe variant resolution
        const gateContext = this.resolveGateContext(context);
        if (gateContext === null) {
            this.logExit({ skipped: 'Unsupported execution context' });
            return;
        }
        // Variant-specific processing
        if (gateContext.type === 'chain') {
            await this.enhanceChainSteps(gateContext, context, registeredGates, frameworksConfig);
            return;
        }
        if (gateContext.type === 'single') {
            await this.enhanceSinglePrompt(gateContext, context, registeredGates, frameworksConfig);
            return;
        }
    }
    /**
     * Enhance a single prompt with gate instructions.
     * Uses GateAccumulator for centralized deduplication with priority-based conflict resolution.
     */
    async enhanceSinglePrompt(gateContext, context, registeredGates, frameworksConfig) {
        const executionPlan = context.executionPlan;
        if (executionPlan === undefined) {
            return;
        }
        const { prompt, inlineGateIds } = gateContext;
        // Include client-selected gates from two-phase judge flow
        const clientSelectedGates = context.state.framework.clientSelectedGates ?? [];
        // Use accumulator for centralized deduplication with priority tracking
        // Priority order (highest to lowest): inline-operator > client-selection > temporary-request > prompt-config > methodology > category-auto
        this.addGatesToAccumulator(context, inlineGateIds, 'inline-operator');
        this.addGatesToAccumulator(context, clientSelectedGates, 'client-selection');
        this.addGatesToAccumulator(context, registeredGates.temporaryGateIds, 'temporary-request');
        this.addGatesToAccumulator(context, executionPlan.gates, 'prompt-config');
        this.addGatesToAccumulator(context, registeredGates.canonicalGateIds, 'methodology');
        // Auto-assign category gates (lowest priority)
        if (prompt.category) {
            const categoryGates = this.getCategoryGates(prompt.category);
            this.addGatesToAccumulator(context, categoryGates, 'category-auto');
        }
        // Get deduplicated gate list from accumulator
        let gateIds = [...context.gates.getAll()];
        const activeFrameworkId = this.getActiveFrameworkId(context);
        gateIds = this.ensureDefaultMethodologyGate(gateIds, frameworksConfig, activeFrameworkId);
        // Filter methodology gates if disabled
        if (frameworksConfig !== undefined && !frameworksConfig.enableMethodologyGates) {
            const beforeCount = gateIds.length;
            gateIds = gateIds.filter((gate) => !this.isMethodologyGate(gate));
            if (beforeCount !== gateIds.length) {
                context.diagnostics.info(this.name, 'Methodology gates filtered by config', {
                    filtered: beforeCount - gateIds.length,
                    remaining: gateIds.length,
                });
            }
        }
        if (gateIds.length === 0) {
            context.diagnostics.info(this.name, 'Gate enhancement skipped - no gates to apply');
            this.logExit({ skipped: 'No gates to apply' });
            return;
        }
        // Record diagnostic for gate accumulation
        context.diagnostics.info(this.name, 'Gates accumulated for single prompt', {
            totalGates: gateIds.length,
            sourceCounts: context.gates.getSourceCounts(),
        });
        try {
            const originalTemplate = prompt.userMessageTemplate ?? '';
            const gateService = this.requireGateService();
            const result = await gateService.enhancePrompt(prompt, gateIds, {
                framework: activeFrameworkId,
                category: executionPlan.category,
                promptId: prompt.id,
                explicitGateIds: inlineGateIds,
            });
            // Extract gate instructions by comparing original vs enhanced template
            const enhancedTemplate = result.enhancedPrompt.userMessageTemplate ?? '';
            if (enhancedTemplate.startsWith(originalTemplate)) {
                // Gate instructions are appended, extract them
                context.gateInstructions = enhancedTemplate.substring(originalTemplate.length).trim();
            }
            executionPlan.gates = gateIds;
            if (result.validationResults !== undefined && result.validationResults.length > 0) {
                context.state.gates.validationResults = result.validationResults;
            }
            this.recordGateUsageMetrics(context, gateIds, result.instructionLength, result.validationResults);
            // Store accumulated gate IDs for downstream stages
            context.state.gates.accumulatedGateIds = gateIds;
            // Single prompts use advisory mode (execute normally, append gate guidance)
            // Chains use blocking mode (pause for gate review before execution)
            const isSinglePrompt = !context.parsedCommand?.steps?.length;
            context.state.gates.hasBlockingGates = !isSinglePrompt && gateIds.length > 0;
            // Enforcement mode: advisory for single prompts, blocking for chains
            if (!context.state.gates.enforcementMode && gateIds.length > 0) {
                context.state.gates.enforcementMode = isSinglePrompt ? 'advisory' : 'blocking';
            }
            this.logExit({
                gateCount: gateIds.length,
                serviceType: gateService.serviceType,
                gateInstructionsStored: Boolean(context.gateInstructions),
                sourceCounts: context.gates.getSourceCounts(),
            });
        }
        catch (error) {
            this.logger.warn('[GateEnhancementStage] Gate enhancement failed', {
                error,
            });
        }
    }
    /**
     * Enhance gate instructions for each step in a multi-step command.
     * Uses GateAccumulator for global gates while handling step-specific gates per step.
     */
    async enhanceChainSteps(gateContext, context, registeredGates, frameworksConfig) {
        const gateService = this.requireGateService();
        const { steps } = gateContext;
        let totalGatesApplied = 0;
        // Add globally applicable gates to the accumulator ONCE
        // These apply to all steps (subject to step filtering)
        const clientSelectedGates = context.state.framework.clientSelectedGates ?? [];
        this.addGatesToAccumulator(context, clientSelectedGates, 'client-selection');
        this.addGatesToAccumulator(context, registeredGates.temporaryGateIds, 'temporary-request');
        this.addGatesToAccumulator(context, registeredGates.canonicalGateIds, 'methodology');
        for (const step of steps) {
            // Each step should have a convertedPrompt (set during parsing)
            const prompt = step.convertedPrompt;
            if (prompt === undefined) {
                this.logger.warn(`[GateEnhancementStage] Skipping step ${step.stepNumber} - no convertedPrompt`);
                continue;
            }
            if (this.shouldSkipGateEnhancement(step.executionPlan?.modifiers)) {
                this.logger.debug('[GateEnhancementStage] Skipping gate enhancement for step due to modifiers', {
                    promptId: step.promptId,
                });
                continue;
            }
            // Planned gates from ExecutionPlanningStage (auto-gates, overrides)
            const plannedGates = Array.isArray(step.executionPlan?.gates) && step.executionPlan.gates.length > 0
                ? step.executionPlan.gates
                : [];
            // Use pre-registered inline gate IDs for this step (if any)
            const stepInlineGates = Array.isArray(step.inlineGateIds) ? step.inlineGateIds : [];
            // Auto-assign gates based on step's category if available
            const categoryGates = prompt.category !== undefined && prompt.category.length > 0
                ? this.getCategoryGates(prompt.category)
                : [];
            // Add step-specific gates to accumulator (they'll be deduplicated against global gates)
            this.addGatesToAccumulator(context, stepInlineGates, 'inline-operator');
            this.addGatesToAccumulator(context, plannedGates, 'prompt-config');
            this.addGatesToAccumulator(context, categoryGates, 'category-auto');
            // Get all accumulated gates (global + step-specific, deduplicated)
            let gateIds = [...context.gates.getAll()];
            // Use getActiveFrameworkId to resolve framework from all sources for default methodology gate
            const activeFrameworkId = this.getActiveFrameworkId(context);
            gateIds = this.ensureDefaultMethodologyGate(gateIds, frameworksConfig, activeFrameworkId);
            if (frameworksConfig !== undefined && !frameworksConfig.enableMethodologyGates) {
                gateIds = gateIds.filter((gate) => !this.isMethodologyGate(gate));
            }
            // Filter gates by step number (for step-specific targeting)
            gateIds = this.filterGatesByStepNumber(gateIds, step.stepNumber);
            if (gateIds.length === 0) {
                continue; // Skip this step if no gates to apply
            }
            try {
                const originalTemplate = prompt.userMessageTemplate ?? '';
                // Use getActiveFrameworkId to resolve framework from all sources:
                // @ operator > client selection from judge phase > global active framework
                // For chain steps, also check step-level framework context
                const frameworkId = step.frameworkContext?.selectedFramework?.id ?? activeFrameworkId;
                const result = await gateService.enhancePrompt(prompt, gateIds, {
                    framework: frameworkId,
                    category: prompt.category,
                    promptId: prompt.id,
                    explicitGateIds: step.inlineGateIds,
                });
                // Extract gate instructions for this step
                const enhancedTemplate = result.enhancedPrompt.userMessageTemplate ?? '';
                if (enhancedTemplate.startsWith(originalTemplate)) {
                    const stepGateInstructions = enhancedTemplate.substring(originalTemplate.length).trim();
                    // Store step-specific gate instructions in step metadata
                    step.metadata ?? (step.metadata = {});
                    step.metadata['gateInstructions'] = stepGateInstructions;
                }
                // DON'T update step's convertedPrompt - keep original template unchanged
                // step.convertedPrompt = result.enhancedPrompt; // REMOVED
                totalGatesApplied += gateIds.length;
                this.recordGateUsageMetrics(context, gateIds, result.instructionLength, result.validationResults);
            }
            catch (error) {
                this.logger.warn(`[GateEnhancementStage] Gate enhancement failed for step ${step.stepNumber}`, {
                    error,
                    promptId: step.promptId,
                });
            }
        }
        // Store accumulated gate IDs for downstream stages (chain path)
        const allGateIds = [...context.gates.getAll()];
        context.state.gates.accumulatedGateIds = allGateIds;
        context.state.gates.hasBlockingGates = totalGatesApplied > 0;
        // Enforcement mode defaults to 'blocking' - can be overridden by response-capture-stage
        // based on gate definitions when they're loaded via GateLoader
        if (!context.state.gates.enforcementMode && allGateIds.length > 0) {
            context.state.gates.enforcementMode = 'blocking';
        }
        this.logExit({
            gateCount: totalGatesApplied,
            stepCount: steps.length,
            serviceType: gateService.serviceType,
            sourceCounts: context.gates.getSourceCounts(),
        });
    }
    /**
     * Get auto-assigned gates based on prompt category
     */
    getCategoryGates(category) {
        const gates = [];
        const normalizedCategory = category?.toLowerCase() ?? 'general';
        switch (normalizedCategory) {
            case 'code_generation':
            case 'development':
                gates.push('code-quality', 'technical-accuracy');
                break;
            case 'analysis':
            case 'research':
                gates.push('research-quality', 'technical-accuracy');
                break;
            case 'documentation':
                gates.push('content-structure', 'educational-clarity');
                break;
            case 'architecture':
                gates.push('technical-accuracy', 'security-awareness');
                break;
        }
        return gates;
    }
    /**
     * Filter gates by step number for step-specific targeting
     *
     * @param gateIds - Array of gate IDs to filter
     * @param stepNumber - Current step number (1-based)
     * @returns Filtered array of gate IDs that apply to this step
     */
    filterGatesByStepNumber(gateIds, stepNumber) {
        if (!this.temporaryGateRegistry) {
            return gateIds; // No filtering if registry unavailable
        }
        return gateIds.filter((gateId) => {
            const tempGate = this.temporaryGateRegistry.getTemporaryGate(gateId);
            // If not a temporary gate, keep it (canonical gates always apply)
            if (!tempGate) {
                return true;
            }
            // If gate has target_step_number, only apply to that specific step
            if (tempGate.target_step_number !== undefined) {
                return tempGate.target_step_number === stepNumber;
            }
            // If gate has apply_to_steps, only apply to those specific steps
            if (tempGate.apply_to_steps !== undefined && tempGate.apply_to_steps.length > 0) {
                return tempGate.apply_to_steps.includes(stepNumber);
            }
            // No step targeting specified - apply to all steps
            return true;
        });
    }
    getMetricsCollector() {
        return this.metricsProvider?.();
    }
    recordGateUsageMetrics(context, gateIds, instructionLength, validationResults) {
        const metrics = this.getMetricsCollector();
        if (metrics === undefined || gateIds.length === 0) {
            return;
        }
        const temporaryIds = new Set(context.state.gates.temporaryGateIds ?? []);
        const validationMap = new Map();
        validationResults?.forEach((result) => validationMap.set(result.gateId, result));
        const baseCharacters = instructionLength !== undefined && gateIds.length > 0
            ? Math.floor(instructionLength / gateIds.length)
            : 0;
        let remainder = instructionLength !== undefined && gateIds.length > 0
            ? instructionLength % gateIds.length
            : 0;
        for (const gateId of gateIds) {
            const isTemporary = temporaryIds.has(gateId) || gateId.startsWith('temp_');
            const validation = validationMap.get(gateId);
            const instructionCharacters = baseCharacters + (remainder > 0 ? 1 : 0);
            if (remainder > 0) {
                remainder--;
            }
            const metric = {
                gateId,
                gateType: isTemporary ? 'temporary' : 'canonical',
                sessionId: context.getSessionId(),
                instructionCount: 1,
                instructionCharacters,
                temporary: isTemporary,
                validationResult: validation !== undefined
                    ? this.toMetricValidationResult(validation)
                    : validationResults !== undefined && validationResults.length > 0
                        ? 'skipped'
                        : undefined,
                metadata: {
                    strategy: context.executionPlan?.strategy,
                    category: context.executionPlan?.category,
                    serviceType: this.gateService?.serviceType,
                },
            };
            metrics.recordGateUsage(metric);
        }
    }
    toMetricValidationResult(validation) {
        return validation.passed ? 'passed' : 'failed';
    }
    /**
     * Normalize gate input to standard format, supporting multiple input styles
     *
     * @param gate - Raw gate input to normalize
     * @param isChainExecution - Whether we're in a chain execution context
     * @param currentStep - Current step number for smart defaults (default: 1)
     */
    normalizeGateInput(gate, isChainExecution = false, currentStep = 1) {
        // Support simple string format: "criteria text"
        if (typeof gate === 'string') {
            return {
                normalized: {
                    name: 'Inline Quality Criteria',
                    type: 'quality',
                    scope: 'execution',
                    criteria: [gate],
                    description: 'Inline quality criteria',
                    source: 'automatic',
                    // Smart default: Apply to current step in chain executions
                    apply_to_steps: isChainExecution ? [currentStep] : undefined,
                },
                isValid: true,
            };
        }
        // Normalize gate type with fallback
        const normalizeType = (type) => {
            const validTypes = [
                'validation',
                'approval',
                'condition',
                'quality',
                'guidance',
            ];
            return validTypes.includes(type)
                ? type
                : 'quality';
        };
        // Normalize scope with fallback
        const normalizeScope = (scope) => {
            const validScopes = ['execution', 'session', 'chain', 'step'];
            return validScopes.includes(scope)
                ? scope
                : 'execution';
        };
        // Normalize source with fallback
        const normalizeSource = (source) => {
            const validSources = ['manual', 'automatic', 'analysis'];
            return validSources.includes(source)
                ? source
                : 'automatic';
        };
        // Convert readonly arrays to mutable arrays and filter for strings
        const normalizeCriteria = (criteria) => {
            if (criteria === undefined || !Array.isArray(criteria))
                return undefined;
            const stringCriteria = criteria.filter((c) => typeof c === 'string');
            return stringCriteria.length > 0 ? stringCriteria : undefined;
        };
        // Normalize context to proper type
        const normalizeContext = (context) => {
            if (context === undefined || context === null)
                return undefined;
            if (typeof context === 'object') {
                return context;
            }
            return undefined;
        };
        // Extract criteria from either criteria or pass_criteria property
        const extractedCriteria = 'criteria' in gate ? gate.criteria : undefined;
        const extractedPassCriteria = 'pass_criteria' in gate ? gate.pass_criteria : undefined;
        // Extract step targeting
        const targetStepNumber = 'target_step_number' in gate && typeof gate.target_step_number === 'number'
            ? gate.target_step_number
            : undefined;
        const applyToSteps = 'apply_to_steps' in gate && Array.isArray(gate.apply_to_steps)
            ? gate.apply_to_steps.filter((n) => typeof n === 'number')
            : undefined;
        // Smart default: If in chain execution and no step-targeting specified, apply to current step
        const effectiveApplyToSteps = applyToSteps && applyToSteps.length > 0
            ? applyToSteps
            : targetStepNumber === undefined && isChainExecution
                ? [currentStep]
                : undefined;
        // Support object with criteria or other gate properties
        return {
            normalized: {
                name: gate.name ?? 'Inline Quality Criteria',
                type: normalizeType(gate.type),
                scope: normalizeScope(gate.scope),
                criteria: normalizeCriteria(extractedCriteria),
                guidance: gate.guidance,
                description: gate.description ?? 'Temporary gate criteria',
                pass_criteria: normalizeCriteria(extractedPassCriteria ?? extractedCriteria),
                source: normalizeSource(gate.source),
                context: normalizeContext(gate.context),
                target_step_number: targetStepNumber,
                apply_to_steps: effectiveApplyToSteps,
            },
            isValid: true,
        };
    }
    /**
     * Register temporary gates from normalized gate specifications.
     * Uses unified 'gates' parameter (already normalized from legacy parameters).
     */
    async registerTemporaryGates(context) {
        this.logger.debug('[GateEnhancementStage] registerTemporaryGates - parsedCommand structure', {
            hasOperators: Boolean(context.parsedCommand?.operators),
            operatorTypes: context.parsedCommand?.operators !== undefined
                ? context.parsedCommand.operators.operatorTypes
                : undefined,
            operatorCount: context.parsedCommand?.operators !== undefined
                ? context.parsedCommand.operators.operators?.length
                : undefined,
            format: context.parsedCommand?.format,
        });
        // Use normalized gates from metadata (unified 'gates' parameter)
        const overrides = context.state.gates.requestedOverrides;
        const normalizedGates = overrides?.gates;
        // Build quality gate set from string gate references in normalized gates
        const qualityGateArray = (normalizedGates ?? []).filter((g) => typeof g === 'string');
        const qualityGateSet = new Set(qualityGateArray);
        const canonicalGateIds = new Set();
        const createdIds = [];
        // Use normalized gates from unified parameter
        const tempGateInputs = normalizedGates ?? [];
        const registry = this.temporaryGateRegistry;
        const registryAvailable = registry !== undefined;
        if (!tempGateInputs.length) {
            return { temporaryGateIds: [], canonicalGateIds: [] };
        }
        const scopeId = context.getSessionId?.() ||
            context.mcpRequest.chain_id ||
            context.mcpRequest.command ||
            'execution';
        // Determine if we're in a chain execution and get current step for smart defaults
        const isChainExecution = context.hasChainCommand() ||
            (context.parsedCommand?.steps !== undefined && context.parsedCommand.steps.length > 1);
        const currentStep = context.sessionContext?.currentStep ?? 1;
        for (const rawGate of tempGateInputs) {
            try {
                const canonicalCandidate = await this.resolveCanonicalGateId(rawGate, qualityGateSet);
                if (canonicalCandidate) {
                    canonicalGateIds.add(canonicalCandidate);
                    qualityGateSet.add(canonicalCandidate);
                    this.logger.debug('[GateEnhancementStage] Resolved canonical gate from temporary input', {
                        gateId: canonicalCandidate,
                    });
                    continue;
                }
                const { normalized: gate, isValid } = this.normalizeGateInput(rawGate, isChainExecution, currentStep);
                if (!isValid) {
                    this.logger.warn('[GateEnhancementStage] Invalid gate format, skipping', {
                        gate: rawGate,
                    });
                    continue;
                }
                const criteria = gate.criteria ?? gate.pass_criteria ?? [];
                const criteriaArray = Array.isArray(criteria)
                    ? criteria.filter((c) => typeof c === 'string')
                    : [];
                let effectiveGuidance = gate.guidance || '';
                if (!effectiveGuidance && criteriaArray.length > 0) {
                    effectiveGuidance = formatCriteriaAsGuidance(criteriaArray);
                    this.logger.debug('[GateEnhancementStage] Auto-generated guidance from criteria', {
                        criteriaCount: criteriaArray.length,
                        guidanceLength: effectiveGuidance.length,
                    });
                }
                else if (!effectiveGuidance && gate.description) {
                    effectiveGuidance = gate.description;
                    this.logger.debug('[GateEnhancementStage] Using description as guidance', {
                        guidanceLength: effectiveGuidance.length,
                    });
                }
                if (!effectiveGuidance && criteriaArray.length === 0 && !gate.description) {
                    this.logger.warn('[GateEnhancementStage] Skipping gate with no usable content (no guidance, criteria, or description)', { gate });
                    continue;
                }
                if (!registryAvailable) {
                    continue;
                }
                // Check if gate already exists (registered by earlier stage with user-provided ID)
                const gateIdCandidate = typeof rawGate === 'object' &&
                    rawGate !== null &&
                    'id' in rawGate &&
                    typeof rawGate.id === 'string'
                    ? rawGate.id
                    : null;
                if (gateIdCandidate && registry.getTemporaryGate(gateIdCandidate)) {
                    this.logger.debug('[GateEnhancementStage] Skipping gate already registered', {
                        gateId: gateIdCandidate,
                    });
                    // Still track it as a canonical gate if needed
                    createdIds.push(gateIdCandidate);
                    continue;
                }
                const gateId = registry.createTemporaryGate({
                    id: gateIdCandidate || undefined, // Preserve user-provided ID if available
                    name: gate.name,
                    type: gate.type,
                    scope: gate.scope,
                    description: gate.description ?? effectiveGuidance.substring(0, 100),
                    guidance: effectiveGuidance,
                    pass_criteria: criteriaArray.length > 0 ? criteriaArray : gate.pass_criteria,
                    source: gate.source,
                    context: gate.context,
                    target_step_number: gate.target_step_number,
                    apply_to_steps: gate.apply_to_steps,
                }, scopeId);
                createdIds.push(gateId);
                this.trackTemporaryGateScope(context, gate.scope ?? 'execution', scopeId);
                this.logger.debug('[GateEnhancementStage] Registered temporary gate', {
                    gateId,
                    name: gate.name,
                    hasGuidance: !!effectiveGuidance,
                    guidanceLength: effectiveGuidance.length,
                    criteriaCount: criteriaArray.length,
                });
            }
            catch (error) {
                this.logger.warn('[GateEnhancementStage] Failed to register temporary gate', {
                    gate: rawGate,
                    error,
                });
            }
        }
        if (registryAvailable && createdIds.length) {
            const existing = context.state.gates.temporaryGateIds ?? [];
            context.state.gates.temporaryGateIds = [...existing, ...createdIds];
            this.logger.info('[GateEnhancementStage] Successfully registered temporary gates', {
                count: createdIds.length,
                gateIds: createdIds,
            });
        }
        if (canonicalGateIds.size > 0) {
            const overrides = context.state.gates.requestedOverrides;
            // Merge canonical gate IDs back into gates array
            const existingGates = overrides?.['gates'] ?? [];
            const existingGateStrings = existingGates.filter((g) => typeof g === 'string');
            const merged = new Set(existingGateStrings);
            canonicalGateIds.forEach((gateId) => merged.add(gateId));
            // Update gates with merged canonical IDs
            if (overrides) {
                const nonStringGates = existingGates.filter((g) => typeof g !== 'string');
                overrides['gates'] = [...Array.from(merged), ...nonStringGates];
            }
            context.state.gates.canonicalGateIdsFromTemporary = Array.from(canonicalGateIds);
        }
        return {
            temporaryGateIds: registryAvailable ? createdIds : [],
            canonicalGateIds: Array.from(canonicalGateIds),
        };
    }
    trackTemporaryGateScope(context, scope, scopeId) {
        if (!scopeId) {
            return;
        }
        const normalizedScope = scope === 'session' || scope === 'chain' || scope === 'step' ? scope : 'execution';
        const scopes = context.state.gates.temporaryGateScopes ?? [];
        if (!context.state.gates.temporaryGateScopes) {
            context.state.gates.temporaryGateScopes = scopes;
        }
        const exists = scopes.some((entry) => entry.scope === normalizedScope && entry.scopeId === scopeId);
        if (!exists) {
            scopes.push({ scope: normalizedScope, scopeId });
        }
    }
    convertCustomChecks(customChecks) {
        if (!Array.isArray(customChecks) || !customChecks.length) {
            return [];
        }
        return customChecks
            .filter((check) => check && (check.name || check.description))
            .map((check) => ({
            name: check.name ?? 'Custom Check',
            type: 'validation',
            scope: 'execution',
            description: check.description ?? check.name ?? '',
            guidance: check.description
                ? `Ensure: ${check.description}`
                : 'Ensure the output satisfies the described custom check.',
            pass_criteria: [],
            source: 'manual',
        }));
    }
    async resolveCanonicalGateId(gate, requestedQualityGates) {
        const candidate = this.extractGateReferenceCandidate(gate);
        if (!candidate || requestedQualityGates.has(candidate)) {
            return undefined;
        }
        if (typeof gate === 'object' && gate !== null && this.gateInputContainsInlineContent(gate)) {
            return undefined;
        }
        if (!this.gateReferenceResolver) {
            return undefined;
        }
        const resolution = await this.gateReferenceResolver.resolve(candidate);
        if (resolution.referenceType === 'registered' &&
            !requestedQualityGates.has(resolution.gateId)) {
            return resolution.gateId;
        }
        return undefined;
    }
    extractGateReferenceCandidate(gate) {
        if (typeof gate === 'string') {
            const trimmed = gate.trim();
            return trimmed.length > 0 ? trimmed : undefined;
        }
        if (gate && typeof gate === 'object') {
            const template = 'template' in gate && typeof gate.template === 'string' ? gate.template : undefined;
            const id = 'id' in gate && typeof gate.id === 'string' ? gate.id : undefined;
            const value = template ?? id;
            const trimmed = value?.trim();
            return trimmed && trimmed.length > 0 ? trimmed : undefined;
        }
        return undefined;
    }
    gateInputContainsInlineContent(gate) {
        const hasCriteria = Array.isArray(gate['criteria']) && gate['criteria'].length > 0;
        const hasPassCriteria = Array.isArray(gate['pass_criteria']) && gate['pass_criteria'].length > 0;
        const hasGuidance = typeof gate['guidance'] === 'string' && gate['guidance'].trim().length > 0;
        const hasDescription = typeof gate['description'] === 'string' && gate['description'].trim().length > 0;
        return hasCriteria || hasPassCriteria || hasGuidance || hasDescription;
    }
}
//# sourceMappingURL=05-gate-enhancement-stage.js.map