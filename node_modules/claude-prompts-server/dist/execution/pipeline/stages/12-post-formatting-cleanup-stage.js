// @lifecycle canonical - Cleans up formatting artifacts before returning output.
import { BasePipelineStage } from '../stage.js';
/**
 * Pipeline Stage 12: Post-Formatting Cleanup
 *
 * Persists inline gate metadata back into the session blueprint and cleans up
 * temporary gates so resumed executions rebuild the same inline requirements.
 *
 * Dependencies: context.executionPlan, context.parsedCommand
 * Output: Updated session blueprint + cleaned temporary gate scopes
 * Can Early Exit: Yes (for non-session executions)
 */
export class PostFormattingCleanupStage extends BasePipelineStage {
    constructor(chainSessionManager, temporaryGateRegistry, logger) {
        super(logger);
        this.chainSessionManager = chainSessionManager;
        this.temporaryGateRegistry = temporaryGateRegistry;
        this.name = 'PostFormattingCleanup';
    }
    async execute(context) {
        this.logEntry(context);
        const sessionId = context.sessionContext?.sessionId;
        if (sessionId && this.chainSessionManager && context.executionPlan && context.parsedCommand) {
            this.persistBlueprint(sessionId, context);
        }
        if (this.temporaryGateRegistry) {
            this.cleanupTemporaryGates(context);
        }
        this.logExit({
            blueprintPersisted: Boolean(sessionId && this.chainSessionManager),
            gatesCleaned: Boolean(this.temporaryGateRegistry),
        });
    }
    persistBlueprint(sessionId, context) {
        const blueprint = {
            parsedCommand: this.clone(context.parsedCommand),
            executionPlan: this.clone(context.executionPlan),
            gateInstructions: context.gateInstructions,
        };
        try {
            this.chainSessionManager.updateSessionBlueprint(sessionId, blueprint);
        }
        catch (error) {
            this.logger.warn('[PostFormattingCleanupStage] Failed to update session blueprint', {
                sessionId,
                error,
            });
        }
    }
    cleanupTemporaryGates(context) {
        const scopeId = context.state.session.executionScopeId;
        if (scopeId) {
            this.temporaryGateRegistry.cleanupScope('execution', scopeId);
        }
        const trackedScopes = this.getTrackedScopes(context);
        for (const { scope, scopeId: trackedScopeId } of trackedScopes) {
            this.temporaryGateRegistry.cleanupScope(scope, trackedScopeId);
        }
    }
    getTrackedScopes(context) {
        const scopesMetadata = context.metadata['temporaryGateScopes'];
        if (!Array.isArray(scopesMetadata)) {
            return [];
        }
        const uniqueScopes = [];
        for (const entry of scopesMetadata) {
            if (!entry?.scope || !entry.scopeId) {
                continue;
            }
            const exists = uniqueScopes.some((item) => item.scope === entry.scope && item.scopeId === entry.scopeId);
            if (!exists) {
                uniqueScopes.push(entry);
            }
        }
        return uniqueScopes;
    }
    clone(value) {
        return JSON.parse(JSON.stringify(value));
    }
}
//# sourceMappingURL=12-post-formatting-cleanup-stage.js.map