import { BasePipelineStage } from '../stage.js';
import type { FrameworkManager } from '../../../frameworks/framework-manager.js';
import type { GateLoader } from '../../../gates/core/gate-loader.js';
import type { TemporaryGateRegistry } from '../../../gates/core/temporary-gate-registry.js';
import type { GateReferenceResolver } from '../../../gates/services/gate-reference-resolver.js';
import type { IGateService } from '../../../gates/services/gate-service-interface.js';
import type { Logger } from '../../../logging/index.js';
import type { MetricsCollector } from '../../../metrics/index.js';
import type { FrameworksConfig, GatesConfig } from '../../../types/index.js';
import type { ExecutionContext } from '../../context/execution-context.js';
type FrameworksConfigProvider = () => FrameworksConfig;
type GatesConfigProvider = () => GatesConfig | undefined;
/**
 * Pipeline Stage 5: Gate Enhancement
 *
 * Renders gate guidance instructions and footer text for quality validation,
 * applying framework-specific and temporary gate criteria to prompts.
 *
 * Dependencies: context.executionPlan, context.convertedPrompt or context.parsedCommand.steps
 * Output: Enhanced prompts with gate instructions, context.activeGateIds
 * Can Early Exit: No
 */
export declare class GateEnhancementStage extends BasePipelineStage {
    private readonly gateService;
    private readonly temporaryGateRegistry;
    private readonly frameworksConfigProvider;
    private readonly gateReferenceResolver;
    private readonly frameworkManagerProvider;
    private readonly gateLoader?;
    readonly name = "GateEnhancement";
    private readonly metricsProvider?;
    private readonly gatesConfigProvider?;
    /** Cached methodology gate IDs loaded from GateLoader */
    private methodologyGateIdsCache;
    constructor(gateService: IGateService | null, temporaryGateRegistry: TemporaryGateRegistry | undefined, frameworksConfigProvider: FrameworksConfigProvider, gateReferenceResolver: GateReferenceResolver | undefined, frameworkManagerProvider: () => FrameworkManager | undefined, logger: Logger, metricsProvider?: () => MetricsCollector | undefined, gatesConfigProvider?: GatesConfigProvider, gateLoader?: GateLoader | undefined);
    /**
     * Get methodology gate IDs dynamically from GateLoader.
     * Caches the result to avoid repeated disk reads.
     */
    private getMethodologyGateIds;
    /**
     * Check if a gate ID is a methodology gate (synchronous check using cache).
     */
    private isMethodologyGate;
    /**
     * Returns gate service with validation.
     * This method should only be called after the null check in execute().
     */
    private requireGateService;
    /**
     * Type-safe resolution of gate enhancement context using type guards.
     * Eliminates runtime errors by using compile-time type narrowing.
     */
    private resolveGateContext;
    /**
     * Add gates to the context accumulator from a specific source.
     * This replaces direct array manipulation with tracked provenance.
     */
    private addGatesToAccumulator;
    private shouldSkipGateEnhancement;
    /**
     * Get the active framework ID from context using FrameworkDecisionAuthority.
     * This ensures consistent framework resolution across all pipeline stages.
     *
     * Priority (handled by authority):
     * 1. Modifiers (%clean, %lean) - disable framework (returns undefined)
     * 2. @ operator override - explicit user intent
     * 3. Client selection from judge phase - user chose
     * 4. Global active framework - system default
     */
    private getActiveFrameworkId;
    /**
     * Ensure methodology validation gate is present when frameworks are active
     */
    private ensureDefaultMethodologyGate;
    /**
     * Build decision input from context for FrameworkDecisionAuthority.
     * This extracts all relevant data for the centralized framework decision.
     */
    private buildDecisionInput;
    execute(context: ExecutionContext): Promise<void>;
    /**
     * Enhance a single prompt with gate instructions.
     * Uses GateAccumulator for centralized deduplication with priority-based conflict resolution.
     */
    private enhanceSinglePrompt;
    /**
     * Enhance gate instructions for each step in a multi-step command.
     * Uses GateAccumulator for global gates while handling step-specific gates per step.
     */
    private enhanceChainSteps;
    /**
     * Get auto-assigned gates based on prompt category
     */
    private getCategoryGates;
    /**
     * Filter gates by step number for step-specific targeting
     *
     * @param gateIds - Array of gate IDs to filter
     * @param stepNumber - Current step number (1-based)
     * @returns Filtered array of gate IDs that apply to this step
     */
    private filterGatesByStepNumber;
    private getMetricsCollector;
    private recordGateUsageMetrics;
    private toMetricValidationResult;
    /**
     * Normalize gate input to standard format, supporting multiple input styles
     *
     * @param gate - Raw gate input to normalize
     * @param isChainExecution - Whether we're in a chain execution context
     * @param currentStep - Current step number for smart defaults (default: 1)
     */
    private normalizeGateInput;
    /**
     * Register temporary gates from normalized gate specifications.
     * Uses unified 'gates' parameter (already normalized from legacy parameters).
     */
    private registerTemporaryGates;
    private trackTemporaryGateScope;
    private convertCustomChecks;
    private resolveCanonicalGateId;
    private extractGateReferenceCandidate;
    private gateInputContainsInlineContent;
}
export {};
