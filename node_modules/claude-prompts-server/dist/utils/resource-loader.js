// @lifecycle canonical - Shared resource loader for JSON/YAML files with caching.
/**
 * Resource Loader
 *
 * Provides JSON/YAML loading with mtime-aware caching and minimal logging.
 * Intended for reuse across gates, frameworks, and prompts to avoid bespoke
 * file parsing logic.
 */
import { existsSync } from 'fs';
import { readFile, stat } from 'fs/promises';
import { extname } from 'path';
import { loadYamlFile } from './yaml/index.js';
export class ResourceLoader {
    constructor(config = {}) {
        this.cache = new Map();
        this.logger = config.logger;
    }
    async load(filePath, options) {
        if (!existsSync(filePath)) {
            return { success: false, filePath, error: `File not found: ${filePath}` };
        }
        const kind = this.resolveKind(filePath, options?.kind);
        const useCache = options?.useCache ?? true;
        try {
            const fileStat = await stat(filePath);
            const cached = this.cache.get(filePath);
            if (useCache && cached && cached.mtimeMs === fileStat.mtimeMs) {
                return {
                    success: true,
                    data: cached.data,
                    filePath,
                    mtimeMs: cached.mtimeMs,
                    fromCache: true,
                };
            }
            const data = kind === 'yaml'
                ? await loadYamlFile(filePath, {
                    ...options?.yamlOptions,
                    required: true,
                    encoding: options?.encoding,
                })
                : await this.loadJson(filePath, options?.encoding);
            // If YAML loader returns undefined despite required=true, treat as error
            if (data === undefined) {
                return {
                    success: false,
                    filePath,
                    error: `Unable to load data from ${filePath}`,
                };
            }
            this.cache.set(filePath, { mtimeMs: fileStat.mtimeMs, data });
            return {
                success: true,
                data,
                filePath,
                mtimeMs: fileStat.mtimeMs,
                fromCache: false,
            };
        }
        catch (error) {
            this.logger?.warn('[ResourceLoader] Failed to load resource', {
                filePath,
                error,
            });
            return {
                success: false,
                filePath,
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    clearCache(filePath) {
        if (filePath) {
            this.cache.delete(filePath);
            return;
        }
        this.cache.clear();
    }
    resolveKind(filePath, explicit) {
        if (explicit && explicit !== 'auto') {
            return explicit;
        }
        const extension = extname(filePath).toLowerCase();
        return extension === '.yaml' || extension === '.yml' ? 'yaml' : 'json';
    }
    async loadJson(filePath, encoding = 'utf8') {
        const content = await readFile(filePath, encoding);
        return JSON.parse(content.toString());
    }
}
//# sourceMappingURL=resource-loader.js.map