// @lifecycle canonical - Manages chain session persistence and lifecycle promotion.
/**
 * Chain Session Manager
 *
 * Manages chain execution sessions, providing the bridge between MCP session IDs
 * and the persisted chain state/step capture utilities. This enables stateful
 * chain execution across multiple MCP tool calls.
 *
 * CRITICAL: Uses file-based persistence to survive STDIO transport's ephemeral processes.
 * Sessions are saved to disk after every change and loaded on initialization.
 */
import * as path from 'path';
import { StepState, } from '../mcp-tools/prompt-engine/core/types.js';
import { FileBackedChainRunRegistry } from './run-registry.js';
const DEFAULT_SESSION_TIMEOUT_MS = 24 * 60 * 60 * 1000;
const DEFAULT_REVIEW_SESSION_TIMEOUT_MS = 30 * 60 * 1000;
const DEFAULT_CLEANUP_INTERVAL_MS = 5 * 60 * 1000;
const MAX_RUN_HISTORY = 10;
const CHAIN_RUN_STORE_VERSION = 2;
/**
 * Chain Session Manager class
 *
 * Coordinates session state between MCP protocol, step capture, and execution context tracking.
 * Provides session-aware context retrieval for chain execution.
 */
export class ChainSessionManager {
    constructor(logger, textReferenceManager, options, argumentHistoryTracker, sessionStore) {
        this.activeSessions = new Map();
        this.chainSessionMapping = new Map(); // chainId -> sessionIds
        this.baseChainMapping = new Map(); // baseChainId -> ordered runIds
        this.runChainToBase = new Map(); // runChainId -> baseChainId
        this.logger = logger;
        this.textReferenceManager = textReferenceManager;
        this.argumentHistoryTracker = argumentHistoryTracker;
        this.serverRoot = options.serverRoot;
        this.defaultSessionTimeoutMs = options?.defaultSessionTimeoutMs ?? DEFAULT_SESSION_TIMEOUT_MS;
        this.reviewSessionTimeoutMs =
            options?.reviewSessionTimeoutMs ?? DEFAULT_REVIEW_SESSION_TIMEOUT_MS;
        this.cleanupIntervalMs = options?.cleanupIntervalMs ?? DEFAULT_CLEANUP_INTERVAL_MS;
        // Set up file-based persistence path - use server root instead of process.cwd()
        const runtimeStateDir = path.join(this.serverRoot, 'runtime-state');
        const chainRunsFilePath = path.join(runtimeStateDir, 'chain-run-registry.json');
        const legacyRunsPath = path.join(runtimeStateDir, 'chain-run-history.json');
        const legacySessionsPath = path.join(runtimeStateDir, 'chain-sessions.json');
        this.runRegistry =
            sessionStore ??
                new FileBackedChainRunRegistry(chainRunsFilePath, this.logger, {
                    fallbackPaths: [legacyRunsPath, legacySessionsPath],
                });
        if (this.logger) {
            this.logger.debug('ChainSessionManager initialized with text reference manager integration');
        }
        // Initialize asynchronously
        this.initialize();
        this.startCleanupScheduler();
    }
    /**
     * Initialize the manager asynchronously
     */
    async initialize() {
        try {
            await this.runRegistry.ensureInitialized();
            await this.loadSessions();
        }
        catch (error) {
            this.logger?.warn(`Failed to initialize ChainSessionManager: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Fire-and-forget cleanup scheduler (unref to avoid blocking shutdown)
     */
    startCleanupScheduler() {
        if (this.cleanupIntervalHandle) {
            this.cleanupIntervalHandle.unref?.();
            return;
        }
        this.cleanupIntervalHandle = setInterval(() => {
            this.cleanupStaleSessions().catch((error) => {
                this.logger?.warn(`Failed to run scheduled session cleanup: ${error instanceof Error ? error.message : String(error)}`);
            });
        }, this.cleanupIntervalMs);
        this.cleanupIntervalHandle.unref?.();
    }
    /**
     * Load sessions from file (for STDIO transport persistence)
     */
    async loadSessions() {
        try {
            const parsed = await this.runRegistry.load();
            const persistedSessions = parsed.runs ?? parsed.sessions ?? {};
            const persistedChainMapping = parsed.runMapping ?? parsed.chainMapping ?? {};
            const persistedBaseMapping = parsed.baseRunMapping ?? parsed.baseChainMapping ?? {};
            // Restore activeSessions Map
            for (const [sessionId, session] of Object.entries(persistedSessions)) {
                const chainSession = session;
                // Deserialize stepStates Map from array format
                if (chainSession.state.stepStates && Array.isArray(chainSession.state.stepStates)) {
                    chainSession.state.stepStates = new Map(chainSession.state.stepStates);
                }
                else if (!chainSession.state.stepStates) {
                    chainSession.state.stepStates = new Map();
                }
                // All persisted sessions become legacy until explicitly resumed
                chainSession.lifecycle = 'legacy';
                this.activeSessions.set(sessionId, chainSession);
            }
            // Restore chainSessionMapping Map
            for (const [chainId, sessionIds] of Object.entries(persistedChainMapping)) {
                this.chainSessionMapping.set(chainId, new Set(sessionIds));
            }
            this.baseChainMapping.clear();
            this.runChainToBase.clear();
            for (const [baseChainId, runChainIds] of Object.entries(persistedBaseMapping)) {
                this.baseChainMapping.set(baseChainId, [...runChainIds]);
            }
            if (parsed.runToBase ?? parsed.runChainToBase) {
                const runToBaseRecord = parsed.runToBase ?? parsed.runChainToBase;
                for (const [runChainId, baseChainId] of Object.entries(runToBaseRecord ?? {})) {
                    if (typeof baseChainId === 'string') {
                        this.runChainToBase.set(runChainId, baseChainId);
                    }
                }
            }
            this.ensureRunMappingConsistency();
            this.logger?.debug?.(`Loaded ${this.activeSessions.size} persisted chain runs from session store`);
        }
        catch (error) {
            this.logger?.warn(`Failed to load persisted sessions: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Save sessions to file (for STDIO transport persistence)
     */
    async saveSessions() {
        await this.persistSessions();
    }
    serializeSessions() {
        const serializedSessions = {};
        for (const [sessionId, session] of this.activeSessions) {
            const sessionCopy = JSON.parse(JSON.stringify(session));
            sessionCopy.lifecycle = session.lifecycle ?? 'canonical';
            if (session.state?.stepStates instanceof Map) {
                sessionCopy.state = sessionCopy.state ?? {};
                sessionCopy.state.stepStates = Array.from(session.state.stepStates.entries());
            }
            serializedSessions[sessionId] = sessionCopy;
        }
        return {
            version: CHAIN_RUN_STORE_VERSION,
            runs: serializedSessions,
            runMapping: Object.fromEntries(Array.from(this.chainSessionMapping.entries()).map(([chainId, sessionIds]) => [
                chainId,
                Array.from(sessionIds),
            ])),
            baseRunMapping: Object.fromEntries(Array.from(this.baseChainMapping.entries()).map(([baseChainId, runIds]) => [
                baseChainId,
                [...runIds],
            ])),
            runToBase: Object.fromEntries(this.runChainToBase.entries()),
        };
    }
    async persistSessions() {
        try {
            const data = this.serializeSessions();
            await this.runRegistry.save(data);
        }
        catch (error) {
            this.logger?.error(`Failed to save sessions: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    persistSessionsAsync(context) {
        this.saveSessions().catch((error) => {
            this.logger?.warn?.(`[ChainSessionManager] Failed to persist sessions (${context}): ${error instanceof Error ? error.message : String(error)}`);
        });
    }
    /**
     * Create a new chain session
     */
    async createSession(sessionId, chainId, totalSteps, originalArgs = {}, options) {
        const session = {
            sessionId,
            chainId,
            state: {
                // Chain sessions track steps using 1-based indexing to align with pipeline expectations
                currentStep: totalSteps > 0 ? 1 : 0,
                totalSteps,
                lastUpdated: Date.now(),
                stepStates: new Map(),
            },
            executionOrder: [],
            startTime: Date.now(),
            lastActivity: Date.now(),
            originalArgs,
            blueprint: options?.blueprint ? this.cloneBlueprint(options.blueprint) : undefined,
            lifecycle: 'canonical',
        };
        this.activeSessions.set(sessionId, session);
        // Track chain to session mapping
        if (!this.chainSessionMapping.has(chainId)) {
            this.chainSessionMapping.set(chainId, new Set());
        }
        this.chainSessionMapping.get(chainId).add(sessionId);
        const baseChainId = this.registerRunHistory(chainId);
        this.pruneExcessRuns(baseChainId);
        // Persist to file
        await this.saveSessions();
        if (this.logger) {
            this.logger.debug(`Created chain session ${sessionId} for chain ${chainId} with ${totalSteps} steps`);
        }
        return session;
    }
    /**
     * Get session by ID
     */
    getSession(sessionId) {
        const session = this.activeSessions.get(sessionId);
        if (session) {
            if (session.state.totalSteps > 0 &&
                (!session.state.currentStep || session.state.currentStep < 1)) {
                session.state.currentStep = 1;
            }
            session.lastActivity = Date.now();
            this.promoteSessionLifecycle(session, 'session-id lookup');
        }
        return session;
    }
    /**
     * Set step state for a specific step
     */
    setStepState(sessionId, stepNumber, state, isPlaceholder = false) {
        const session = this.activeSessions.get(sessionId);
        if (!session) {
            this.logger?.warn(`[StepLifecycle] Cannot set step state for non-existent session: ${sessionId}`);
            return false;
        }
        if (!session.state.stepStates) {
            session.state.stepStates = new Map();
        }
        const existing = session.state.stepStates.get(stepNumber);
        const now = Date.now();
        const metadata = {
            state,
            isPlaceholder,
            renderedAt: existing?.renderedAt || (state === StepState.RENDERED ? now : undefined),
            respondedAt: state === StepState.RESPONSE_CAPTURED ? now : existing?.respondedAt,
            completedAt: state === StepState.COMPLETED ? now : existing?.completedAt,
        };
        session.state.stepStates.set(stepNumber, metadata);
        this.logger?.debug(`[StepLifecycle] Step ${stepNumber} state set to ${state} (placeholder: ${isPlaceholder})`);
        return true;
    }
    /**
     * Get step state for a specific step
     */
    getStepState(sessionId, stepNumber) {
        const session = this.activeSessions.get(sessionId);
        if (!session?.state.stepStates) {
            return undefined;
        }
        return session.state.stepStates.get(stepNumber);
    }
    /**
     * Transition step to a new state
     */
    async transitionStepState(sessionId, stepNumber, newState, isPlaceholder = false) {
        const session = this.activeSessions.get(sessionId);
        if (!session) {
            this.logger?.warn(`[StepLifecycle] Cannot transition step state for non-existent session: ${sessionId}`);
            return false;
        }
        const currentMetadata = this.getStepState(sessionId, stepNumber);
        const currentState = currentMetadata?.state;
        // Log state transition
        this.logger?.debug(`[StepLifecycle] Transitioning step ${stepNumber} from ${currentState || 'NONE'} to ${newState}`);
        // Set the new state
        this.setStepState(sessionId, stepNumber, newState, isPlaceholder);
        // Persist to file
        await this.saveSessions();
        return true;
    }
    /**
     * Check if a step is complete (not a placeholder and in COMPLETED state)
     */
    isStepComplete(sessionId, stepNumber) {
        const metadata = this.getStepState(sessionId, stepNumber);
        return metadata?.state === StepState.COMPLETED && !metadata.isPlaceholder;
    }
    /**
     * Update session state after step rendering or completion
     * IMPORTANT: This method now handles both rendering (template storage) and completion
     */
    async updateSessionState(sessionId, stepNumber, stepResult, stepMetadata) {
        const session = this.activeSessions.get(sessionId);
        if (!session) {
            if (this.logger) {
                this.logger.warn(`Attempted to update non-existent session: ${sessionId}`);
            }
            return false;
        }
        const metadataRecord = {
            ...(stepMetadata || {}),
            isPlaceholder: stepMetadata?.['isPlaceholder'] ?? false,
            storedAt: Date.now(),
        };
        const isPlaceholder = metadataRecord.isPlaceholder;
        // Determine the appropriate state based on whether this is a placeholder
        const stepState = isPlaceholder ? StepState.RENDERED : StepState.RESPONSE_CAPTURED;
        // Update step state tracking
        this.setStepState(sessionId, stepNumber, stepState, isPlaceholder);
        // Only increment currentStep if this is NOT a placeholder (real completion)
        if (!isPlaceholder) {
            session.state.currentStep = stepNumber + 1; // Move to next step
            session.executionOrder.push(stepNumber);
            this.logger?.debug(`[StepLifecycle] Step ${stepNumber} completed with real response, advancing to step ${session.state.currentStep}`);
        }
        else {
            this.logger?.debug(`[StepLifecycle] Step ${stepNumber} rendered with template placeholder, NOT advancing currentStep`);
        }
        session.state.lastUpdated = Date.now();
        session.lastActivity = Date.now();
        this.persistStepResult(session, stepNumber, stepResult, metadataRecord, metadataRecord.isPlaceholder);
        // Persist to file
        await this.saveSessions();
        return true;
    }
    /**
     * Update an existing step result (e.g., replace placeholder with LLM output)
     */
    async updateStepResult(sessionId, stepNumber, stepResult, stepMetadata) {
        const session = this.activeSessions.get(sessionId);
        if (!session) {
            if (this.logger) {
                this.logger.warn(`Attempted to update result for non-existent session: ${sessionId}`);
            }
            return false;
        }
        const existingMetadata = this.textReferenceManager.getChainStepMetadata(session.chainId, stepNumber) || {};
        const mergedMetadata = {
            ...existingMetadata,
            ...(stepMetadata || {}),
            isPlaceholder: stepMetadata?.['isPlaceholder'] ?? false,
            updatedAt: Date.now(),
        };
        const isPlaceholder = mergedMetadata.isPlaceholder;
        // Update step state: if we're replacing a placeholder with real content, transition to RESPONSE_CAPTURED
        if (!isPlaceholder) {
            this.setStepState(sessionId, stepNumber, StepState.RESPONSE_CAPTURED, false);
            this.logger?.debug(`[StepLifecycle] Step ${stepNumber} updated with real response, state transitioned to RESPONSE_CAPTURED`);
        }
        this.persistStepResult(session, stepNumber, stepResult, mergedMetadata, mergedMetadata.isPlaceholder);
        session.lastActivity = Date.now();
        session.state.lastUpdated = Date.now();
        await this.saveSessions();
        return true;
    }
    /**
     * Mark a step as COMPLETED and advance the step counter
     * This should be called AFTER the step response has been captured and validated
     */
    async completeStep(sessionId, stepNumber, options) {
        const session = this.activeSessions.get(sessionId);
        if (!session) {
            this.logger?.warn(`[StepLifecycle] Cannot complete step for non-existent session: ${sessionId}`);
            return false;
        }
        const existingMetadata = this.getStepState(sessionId, stepNumber);
        const preservePlaceholder = Boolean(options?.preservePlaceholder);
        const isPlaceholder = preservePlaceholder ? Boolean(existingMetadata?.isPlaceholder) : false;
        const shouldAdvanceStep = !preservePlaceholder && session.state.currentStep <= stepNumber;
        // Transition to COMPLETED state while respecting placeholder metadata when requested
        this.setStepState(sessionId, stepNumber, StepState.COMPLETED, isPlaceholder);
        // Advance the currentStep counter if not already advanced
        if (shouldAdvanceStep) {
            session.state.currentStep = stepNumber + 1;
            session.executionOrder.push(stepNumber);
            this.logger?.debug(`[StepLifecycle] Step ${stepNumber} marked COMPLETED, advancing to step ${session.state.currentStep}`);
        }
        else if (preservePlaceholder) {
            this.logger?.debug(`[StepLifecycle] Step ${stepNumber} marked COMPLETED as placeholder, NOT advancing currentStep`);
        }
        session.state.lastUpdated = Date.now();
        session.lastActivity = Date.now();
        await this.saveSessions();
        return true;
    }
    /**
     * Persist a step result to storage and optional tracking systems.
     */
    persistStepResult(session, stepNumber, stepResult, metadata, isPlaceholder) {
        const metadataPayload = {
            ...metadata,
            isPlaceholder,
        };
        this.textReferenceManager.storeChainStepResult(session.chainId, stepNumber, stepResult, metadataPayload);
        if (this.argumentHistoryTracker && !isPlaceholder) {
            try {
                this.argumentHistoryTracker.trackExecution({
                    promptId: session.chainId,
                    sessionId: session.sessionId,
                    originalArgs: session.originalArgs || {},
                    stepNumber,
                    stepResult,
                    metadata: {
                        executionType: 'chain',
                        chainId: session.chainId,
                        ...metadataPayload,
                    },
                });
            }
            catch (error) {
                this.logger?.error('[ChainSessionManager] Failed to track argument history entry', {
                    chainId: session.chainId,
                    stepNumber,
                    error,
                });
            }
        }
    }
    /**
     * Get chain context for session - this is the critical method for fixing contextData
     */
    getChainContext(sessionId) {
        const session = this.activeSessions.get(sessionId);
        if (!session) {
            this.logger.debug(`No session found for ${sessionId}, returning empty context`);
            return {};
        }
        // Get chain variables from text reference manager (single source of truth)
        const chainVariables = this.textReferenceManager.buildChainVariables(session.chainId);
        // Get original arguments + previous results from ArgumentHistoryTracker (with graceful fallback)
        let argumentContext = {};
        let reviewContext;
        if (this.argumentHistoryTracker) {
            try {
                reviewContext = this.argumentHistoryTracker.buildReviewContext(sessionId, session.state.currentStep);
                argumentContext = reviewContext.originalArgs;
            }
            catch (error) {
                // Fallback to session's originalArgs if tracker fails
                this.logger.debug(`Failed to get arguments from ArgumentHistoryTracker, using session originalArgs: ${error instanceof Error ? error.message : String(error)}`);
                argumentContext = session.originalArgs;
            }
        }
        else {
            // Fallback to session's originalArgs if tracker not available
            argumentContext = session.originalArgs;
        }
        // Merge with session-specific context
        const contextData = {
            // Core session info
            chain_run_id: sessionId,
            chain_id: session.chainId,
            current_step: session.state.currentStep,
            total_steps: session.state.totalSteps,
            execution_order: session.executionOrder,
            // Chain variables (step results, etc.) from TextReferenceManager
            ...chainVariables,
            // Original arguments - NOW INCLUDED!
            ...argumentContext,
        };
        if (reviewContext && Object.keys(reviewContext.previousResults).length > 0) {
            contextData.previous_step_results = { ...reviewContext.previousResults };
        }
        const currentStepArgs = this.getCurrentStepArgs(session);
        if (currentStepArgs && Object.keys(currentStepArgs).length > 0) {
            contextData.currentStepArgs = currentStepArgs;
        }
        const chainMetadata = this.buildChainMetadata(session);
        if (chainMetadata) {
            contextData.chain_metadata = chainMetadata;
        }
        this.logger.debug(`Retrieved context for session ${sessionId}: ${Object.keys(contextData).length} context variables (including ${Object.keys(argumentContext).length} original arguments)`);
        return contextData;
    }
    /**
     * Get original arguments for session
     */
    getOriginalArgs(sessionId) {
        const session = this.activeSessions.get(sessionId);
        return session?.originalArgs || {};
    }
    getSessionBlueprint(sessionId) {
        const session = this.activeSessions.get(sessionId);
        if (!session?.blueprint) {
            return undefined;
        }
        return this.cloneBlueprint(session.blueprint);
    }
    updateSessionBlueprint(sessionId, blueprint) {
        const session = this.activeSessions.get(sessionId);
        if (!session) {
            if (this.logger) {
                this.logger.warn(`[ChainSessionManager] Attempted to update blueprint for non-existent session: ${sessionId}`);
            }
            return;
        }
        session.blueprint = this.cloneBlueprint(blueprint);
        this.saveSessions().catch((error) => {
            if (this.logger) {
                this.logger.error(`[ChainSessionManager] Failed to persist blueprint for ${sessionId}`, error);
            }
        });
    }
    getInlineGateIds(sessionId) {
        const session = this.activeSessions.get(sessionId);
        if (!session?.blueprint?.parsedCommand) {
            return undefined;
        }
        const inlineIds = this.collectInlineGateIds(session.blueprint.parsedCommand);
        return inlineIds.length > 0 ? inlineIds : undefined;
    }
    async setPendingGateReview(sessionId, review) {
        const session = this.activeSessions.get(sessionId);
        if (!session) {
            if (this.logger) {
                this.logger.warn(`Attempted to set pending gate review for non-existent session: ${sessionId}`);
            }
            return;
        }
        session.pendingGateReview = {
            ...review,
            gateIds: [...review.gateIds],
            prompts: review.prompts.map((prompt) => ({
                ...prompt,
                explicitInstructions: prompt.explicitInstructions
                    ? [...prompt.explicitInstructions]
                    : undefined,
                metadata: prompt.metadata ? { ...prompt.metadata } : undefined,
            })),
            retryHints: review.retryHints ? [...review.retryHints] : undefined,
            history: review.history ? review.history.map((entry) => ({ ...entry })) : undefined,
            metadata: review.metadata ? { ...review.metadata } : undefined,
        };
        await this.saveSessions();
    }
    getPendingGateReview(sessionId) {
        const session = this.activeSessions.get(sessionId);
        if (!session?.pendingGateReview) {
            return undefined;
        }
        const review = session.pendingGateReview;
        return {
            ...review,
            gateIds: [...review.gateIds],
            prompts: review.prompts.map((prompt) => ({
                ...prompt,
                explicitInstructions: prompt.explicitInstructions
                    ? [...prompt.explicitInstructions]
                    : undefined,
                metadata: prompt.metadata ? { ...prompt.metadata } : undefined,
            })),
            retryHints: review.retryHints ? [...review.retryHints] : undefined,
            history: review.history ? review.history.map((entry) => ({ ...entry })) : undefined,
            metadata: review.metadata ? { ...review.metadata } : undefined,
        };
    }
    /**
     * Check if the retry limit has been exceeded for a pending gate review.
     * Returns true if attemptCount >= maxAttempts.
     * @remarks Uses DEFAULT_RETRY_LIMIT (2) when maxAttempts not specified.
     */
    isRetryLimitExceeded(sessionId) {
        const review = this.getPendingGateReview(sessionId);
        if (!review) {
            return false;
        }
        // Import would create circular dependency, so we inline the default (2)
        // This matches DEFAULT_RETRY_LIMIT from gates/constants.ts
        const maxAttempts = review.maxAttempts ?? 2;
        return (review.attemptCount ?? 0) >= maxAttempts;
    }
    /**
     * Reset the retry count for a pending gate review.
     * Used when user chooses to retry after retry exhaustion.
     */
    async resetRetryCount(sessionId) {
        const session = this.activeSessions.get(sessionId);
        if (!session?.pendingGateReview) {
            this.logger?.debug?.(`[ChainSessionManager] No pending gate review to reset for session: ${sessionId}`);
            return;
        }
        // Reset attempt count and log in history
        session.pendingGateReview.attemptCount = 0;
        session.pendingGateReview.history = session.pendingGateReview.history ?? [];
        session.pendingGateReview.history.push({
            timestamp: Date.now(),
            status: 'reset',
            reasoning: 'User requested retry after exhaustion',
        });
        await this.saveSessions();
        this.logger?.info?.(`[ChainSessionManager] Reset retry count for session: ${sessionId}`);
    }
    async clearPendingGateReview(sessionId) {
        const session = this.activeSessions.get(sessionId);
        if (!session?.pendingGateReview) {
            return;
        }
        delete session.pendingGateReview;
        await this.saveSessions();
    }
    async recordGateReviewOutcome(sessionId, outcome) {
        const session = this.activeSessions.get(sessionId);
        if (!session?.pendingGateReview) {
            this.logger?.warn(`[GateReview] Attempted to record verdict for non-existent session: ${sessionId}`);
            return 'pending';
        }
        const review = session.pendingGateReview;
        const timestamp = Date.now();
        review.history ?? (review.history = []);
        review.history.push({
            timestamp,
            status: outcome.verdict.toLowerCase(),
            reasoning: outcome.rationale,
            reviewer: outcome.reviewer,
        });
        review.previousResponse = outcome.rawVerdict;
        review.attemptCount = (review.attemptCount ?? 0) + 1;
        if (outcome.verdict === 'PASS') {
            delete session.pendingGateReview;
            await this.saveSessions();
            this.logger?.info('[GateReview] Cleared pending review', {
                sessionId,
                gateIds: review.gateIds,
            });
            return 'cleared';
        }
        await this.saveSessions();
        this.logger?.info('[GateReview] Review failed, awaiting remediation', {
            sessionId,
            gateIds: review.gateIds,
        });
        return 'pending';
    }
    /**
     * Check if session exists and is active
     */
    hasActiveSession(sessionId) {
        return this.activeSessions.has(sessionId);
    }
    /**
     * Check if chain has any active sessions
     */
    hasActiveSessionForChain(chainId) {
        const sessionIds = this.chainSessionMapping.get(chainId);
        if (!sessionIds) {
            return false;
        }
        for (const sessionId of sessionIds) {
            const session = this.activeSessions.get(sessionId);
            if (session && !this.isLegacySession(session)) {
                return true;
            }
        }
        return false;
    }
    getRunHistory(baseChainId) {
        const normalized = this.extractBaseChainId(baseChainId);
        const history = this.baseChainMapping.get(normalized);
        if (history && history.length > 0) {
            return [...history];
        }
        if (this.chainSessionMapping.has(normalized)) {
            return [normalized];
        }
        const fallbackRuns = Array.from(this.chainSessionMapping.keys()).filter((chainId) => this.extractBaseChainId(chainId) === normalized);
        return fallbackRuns.sort((a, b) => {
            const runA = this.getRunNumber(a) ?? 0;
            const runB = this.getRunNumber(b) ?? 0;
            return runA - runB;
        });
    }
    getLatestSessionForBaseChain(baseChainId) {
        const normalized = this.extractBaseChainId(baseChainId);
        const history = this.baseChainMapping.get(normalized);
        if (history && history.length > 0) {
            for (let idx = history.length - 1; idx >= 0; idx -= 1) {
                const runChainId = history[idx];
                const sessionIds = this.chainSessionMapping.get(runChainId);
                if (!sessionIds) {
                    continue;
                }
                for (const sessionId of sessionIds) {
                    const session = this.activeSessions.get(sessionId);
                    if (session && !this.isLegacySession(session)) {
                        return session;
                    }
                }
            }
        }
        return this.getActiveSessionForChain(normalized);
    }
    getSessionByChainIdentifier(chainId, options) {
        const includeLegacy = options?.includeLegacy ?? false;
        const runSession = this.getActiveSessionForChain(chainId);
        if (runSession) {
            return runSession;
        }
        if (includeLegacy) {
            const legacyRun = this.getLegacySessionForChain(chainId);
            if (legacyRun) {
                this.promoteSessionLifecycle(legacyRun, 'explicit chain resume');
                return legacyRun;
            }
        }
        const normalized = this.extractBaseChainId(chainId);
        const latestActive = this.getLatestSessionForBaseChain(normalized);
        if (latestActive) {
            return latestActive;
        }
        if (includeLegacy) {
            const legacy = this.getLegacySessionForBaseChain(normalized);
            if (legacy) {
                this.promoteSessionLifecycle(legacy, 'explicit base chain resume');
                return legacy;
            }
        }
        return undefined;
    }
    listActiveSessions(limit = 50) {
        const summaries = [];
        for (const session of this.activeSessions.values()) {
            if (this.isLegacySession(session)) {
                continue;
            }
            summaries.push({
                sessionId: session.sessionId,
                chainId: session.chainId,
                currentStep: session.state.currentStep,
                totalSteps: session.state.totalSteps,
                pendingReview: Boolean(session.pendingGateReview),
                lastActivity: session.lastActivity,
                startTime: session.startTime,
                promptName: session.blueprint?.parsedCommand?.convertedPrompt?.name,
                promptId: session.blueprint?.parsedCommand?.convertedPrompt?.id ??
                    session.blueprint?.parsedCommand?.promptId,
            });
        }
        summaries.sort((a, b) => b.lastActivity - a.lastActivity);
        return limit > 0 ? summaries.slice(0, limit) : summaries;
    }
    /**
     * Get active session for chain (returns first active session)
     */
    getActiveSessionForChain(chainId) {
        const sessionIds = this.chainSessionMapping.get(chainId);
        if (!sessionIds || sessionIds.size === 0) {
            return undefined;
        }
        // Return the most recently active session
        let mostRecentSession;
        let mostRecentActivity = 0;
        for (const sessionId of sessionIds) {
            const session = this.activeSessions.get(sessionId);
            if (session && !this.isLegacySession(session) && session.lastActivity > mostRecentActivity) {
                mostRecentSession = session;
                mostRecentActivity = session.lastActivity;
            }
        }
        return mostRecentSession;
    }
    /**
     * Clear session
     */
    async clearSession(sessionId) {
        const session = this.activeSessions.get(sessionId);
        if (!session) {
            return false;
        }
        this.removeSessionArtifacts(sessionId);
        // Remove from chain mapping
        const chainSessions = this.chainSessionMapping.get(session.chainId);
        if (chainSessions) {
            chainSessions.delete(sessionId);
            if (chainSessions.size === 0) {
                this.chainSessionMapping.delete(session.chainId);
                this.removeRunFromBaseTracking(session.chainId);
                this.textReferenceManager.clearChainStepResults(session.chainId);
            }
        }
        // Persist to file
        await this.saveSessions();
        if (this.logger) {
            this.logger.debug(`Cleared session ${sessionId} for chain ${session.chainId}`);
        }
        return true;
    }
    /**
     * Clear all sessions for a chain
     */
    async clearSessionsForChain(chainId) {
        const baseChainId = this.extractBaseChainId(chainId);
        const runChainIds = chainId === baseChainId ? [...this.getRunHistory(baseChainId)] : [chainId];
        if (runChainIds.length === 0 && this.chainSessionMapping.has(chainId)) {
            runChainIds.push(chainId);
        }
        for (const runChainId of runChainIds) {
            this.removeRunChainSessions(runChainId);
            this.textReferenceManager.clearChainStepResults(runChainId);
            this.removeRunFromBaseTracking(runChainId);
        }
        // Persist to file
        await this.saveSessions();
        if (this.logger) {
            this.logger.debug(`Cleared all sessions for chain ${chainId}`);
        }
    }
    /**
     * Cleanup stale sessions (older than 24 hours)
     */
    async cleanupStaleSessions() {
        const now = Date.now();
        const reviewThreshold = now - this.reviewSessionTimeoutMs;
        const defaultThreshold = now - this.defaultSessionTimeoutMs;
        let cleaned = 0;
        const staleSessionIds = [];
        for (const [sessionId, session] of this.activeSessions) {
            const isReviewSession = session.chainId.startsWith('prompt-review-');
            const threshold = isReviewSession ? reviewThreshold : defaultThreshold;
            if (session.lastActivity < threshold) {
                staleSessionIds.push(sessionId);
            }
        }
        for (const sessionId of staleSessionIds) {
            const session = this.activeSessions.get(sessionId);
            await this.clearSession(sessionId);
            cleaned++;
            if (session?.chainId?.startsWith('prompt-review-')) {
                this.logger?.info('[GateReview] Cleaned abandoned prompt review session', {
                    sessionId,
                    chainId: session.chainId,
                    lastActivity: session?.lastActivity,
                });
            }
        }
        if (cleaned > 0) {
            this.logger?.info(`Cleaned up ${cleaned} stale chain sessions (default timeout ${this.defaultSessionTimeoutMs}ms, review timeout ${this.reviewSessionTimeoutMs}ms)`);
        }
        return cleaned;
    }
    registerRunHistory(chainId) {
        const baseChainId = this.extractBaseChainId(chainId);
        const history = this.baseChainMapping.get(baseChainId) ?? [];
        const existingIndex = history.indexOf(chainId);
        if (existingIndex >= 0) {
            history.splice(existingIndex, 1);
        }
        history.push(chainId);
        this.baseChainMapping.set(baseChainId, history);
        this.runChainToBase.set(chainId, baseChainId);
        return baseChainId;
    }
    pruneExcessRuns(baseChainId) {
        const history = this.baseChainMapping.get(baseChainId);
        if (!history) {
            return;
        }
        while (history.length > MAX_RUN_HISTORY) {
            const removedChainId = history.shift();
            if (!removedChainId) {
                break;
            }
            const removedSessions = this.removeRunChainSessions(removedChainId);
            this.textReferenceManager.clearChainStepResults(removedChainId);
            this.removeRunFromBaseTracking(removedChainId);
            this.logger?.info(`Pruned oldest run ${removedChainId} for base ${baseChainId} (keeping ${MAX_RUN_HISTORY} runs)`, { removedSessions });
        }
        if (history.length === 0) {
            this.baseChainMapping.delete(baseChainId);
        }
    }
    removeRunChainSessions(chainId) {
        const sessionIds = this.chainSessionMapping.get(chainId);
        const removedSessions = [];
        if (sessionIds) {
            for (const sessionId of sessionIds) {
                this.removeSessionArtifacts(sessionId);
                removedSessions.push(sessionId);
            }
            this.chainSessionMapping.delete(chainId);
        }
        return removedSessions;
    }
    removeSessionArtifacts(sessionId) {
        if (this.argumentHistoryTracker) {
            try {
                this.argumentHistoryTracker.clearSession(sessionId);
                this.logger.debug(`Cleared argument history for session ${sessionId}`);
            }
            catch (error) {
                this.logger.warn(`Failed to clear argument history for session ${sessionId}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
        this.activeSessions.delete(sessionId);
    }
    removeRunFromBaseTracking(chainId) {
        const baseChainId = this.runChainToBase.get(chainId) ?? this.extractBaseChainId(chainId);
        const history = this.baseChainMapping.get(baseChainId);
        if (history) {
            const filtered = history.filter((entry) => entry !== chainId);
            if (filtered.length > 0) {
                this.baseChainMapping.set(baseChainId, filtered);
            }
            else {
                this.baseChainMapping.delete(baseChainId);
            }
        }
        this.runChainToBase.delete(chainId);
    }
    extractBaseChainId(chainId) {
        return chainId.replace(/#\d+$/, '');
    }
    getRunNumber(chainId) {
        const match = chainId.match(/#(\d+)$/);
        if (!match) {
            return undefined;
        }
        return Number.parseInt(match[1], 10);
    }
    ensureRunMappingConsistency() {
        for (const chainId of this.chainSessionMapping.keys()) {
            const baseChainId = this.extractBaseChainId(chainId);
            if (!this.baseChainMapping.has(baseChainId)) {
                this.baseChainMapping.set(baseChainId, []);
            }
            const history = this.baseChainMapping.get(baseChainId);
            if (!history.includes(chainId)) {
                history.push(chainId);
                history.sort((a, b) => {
                    const runA = this.getRunNumber(a) ?? 0;
                    const runB = this.getRunNumber(b) ?? 0;
                    return runA - runB;
                });
            }
            if (!this.runChainToBase.has(chainId)) {
                this.runChainToBase.set(chainId, baseChainId);
            }
        }
        for (const [runChainId, baseChainId] of Array.from(this.runChainToBase.entries())) {
            if (!this.chainSessionMapping.has(runChainId)) {
                this.runChainToBase.delete(runChainId);
                const history = this.baseChainMapping.get(baseChainId);
                if (history) {
                    const filtered = history.filter((entry) => entry !== runChainId);
                    if (filtered.length > 0) {
                        this.baseChainMapping.set(baseChainId, filtered);
                    }
                    else {
                        this.baseChainMapping.delete(baseChainId);
                    }
                }
            }
        }
    }
    /**
     * Get session statistics
     */
    getSessionStats() {
        const totalSessions = this.activeSessions.size;
        const totalChains = this.chainSessionMapping.size;
        let totalSteps = 0;
        let oldestSessionTime = Date.now();
        for (const session of this.activeSessions.values()) {
            totalSteps += session.state.currentStep;
            if (session.startTime < oldestSessionTime) {
                oldestSessionTime = session.startTime;
            }
        }
        return {
            totalSessions,
            totalChains,
            averageStepsPerChain: totalChains > 0 ? totalSteps / totalChains : 0,
            oldestSessionAge: Date.now() - oldestSessionTime,
        };
    }
    /**
     * Validate session integrity
     */
    validateSession(sessionId) {
        const session = this.activeSessions.get(sessionId);
        const issues = [];
        if (!session) {
            issues.push('Session not found');
            return { valid: false, issues };
        }
        // Check for stale session
        const hoursSinceActivity = (Date.now() - session.lastActivity) / 3600000;
        if (hoursSinceActivity > 1) {
            issues.push(`Session stale: ${hoursSinceActivity.toFixed(1)} hours since last activity`);
        }
        return { valid: issues.length === 0, issues };
    }
    /**
     * Cleanup the chain session manager and persist state
     * Prevents async handle leaks by finalizing all file operations
     */
    async cleanup() {
        this.logger.info('Shutting down ChainSessionManager...');
        try {
            if (this.cleanupIntervalHandle) {
                clearInterval(this.cleanupIntervalHandle);
                this.cleanupIntervalHandle = undefined;
                this.logger.debug('Chain session cleanup scheduler cleared');
            }
            // Perform final state save to persist any pending session data
            await this.saveSessions();
            this.logger.debug('Chain sessions persisted during cleanup');
        }
        catch (error) {
            this.logger.warn('Error persisting sessions during cleanup:', error);
        }
        // Clear in-memory state
        this.activeSessions.clear();
        this.chainSessionMapping.clear();
        this.baseChainMapping.clear();
        this.runChainToBase.clear();
        this.logger.debug('In-memory session state cleared');
        this.logger.info('ChainSessionManager cleanup complete');
    }
    isLegacySession(session) {
        return session?.lifecycle === 'legacy';
    }
    promoteSessionLifecycle(session, reason) {
        if (session.lifecycle === 'canonical') {
            return;
        }
        session.lifecycle = 'canonical';
        this.logger?.debug?.(`[ChainSessionManager] Promoted session ${session.sessionId} to canonical (${reason})`);
        this.persistSessionsAsync('lifecycle-promotion');
    }
    getLegacySessionForChain(chainId) {
        const sessionIds = this.chainSessionMapping.get(chainId);
        if (!sessionIds) {
            return undefined;
        }
        for (const sessionId of sessionIds) {
            const session = this.activeSessions.get(sessionId);
            if (session && this.isLegacySession(session)) {
                return session;
            }
        }
        return undefined;
    }
    getLegacySessionForBaseChain(baseChainId) {
        const normalized = this.extractBaseChainId(baseChainId);
        const history = this.baseChainMapping.get(normalized) ?? [];
        for (let idx = history.length - 1; idx >= 0; idx -= 1) {
            const runChainId = history[idx];
            const legacySession = this.getLegacySessionForChain(runChainId);
            if (legacySession) {
                return legacySession;
            }
        }
        return this.getLegacySessionForChain(normalized);
    }
    buildChainMetadata(session) {
        const blueprint = session.blueprint;
        const baseMetadata = {
            chainId: session.chainId,
            chainRunId: session.sessionId,
            totalSteps: session.state.totalSteps,
            currentStep: session.state.currentStep,
        };
        if (!blueprint) {
            return baseMetadata;
        }
        const parsed = blueprint.parsedCommand;
        const convertedPrompt = parsed?.convertedPrompt;
        const plan = blueprint.executionPlan;
        const metadata = {
            ...baseMetadata,
            promptId: convertedPrompt?.id ?? parsed?.promptId ?? session.chainId,
            name: convertedPrompt?.name ?? parsed?.promptId ?? session.chainId,
            description: convertedPrompt?.description,
            category: convertedPrompt?.category,
            gates: plan?.gates ?? [],
            strategy: plan?.strategy,
            inlineGateIds: this.collectInlineGateIds(parsed),
        };
        return metadata;
    }
    collectInlineGateIds(parsedCommand) {
        if (!parsedCommand) {
            return [];
        }
        const ids = new Set();
        const recordIds = (values) => {
            if (!Array.isArray(values)) {
                return;
            }
            for (const id of values) {
                if (typeof id === 'string' && id.trim().length > 0) {
                    ids.add(id);
                }
            }
        };
        recordIds(parsedCommand.inlineGateIds);
        if (Array.isArray(parsedCommand.steps)) {
            for (const step of parsedCommand.steps) {
                recordIds(step.inlineGateIds);
            }
        }
        return Array.from(ids);
    }
    getCurrentStepArgs(session) {
        const blueprintSteps = session.blueprint?.parsedCommand?.steps;
        if (!Array.isArray(blueprintSteps) || blueprintSteps.length === 0) {
            return undefined;
        }
        const currentStep = typeof session.state.currentStep === 'number' ? session.state.currentStep : 1;
        const maxIndex = blueprintSteps.length - 1;
        const resolvedIndex = Math.min(Math.max(currentStep - 1, 0), maxIndex);
        const args = blueprintSteps[resolvedIndex]?.args;
        if (!args || Object.keys(args).length === 0) {
            return undefined;
        }
        return { ...args };
    }
    cloneBlueprint(blueprint) {
        return JSON.parse(JSON.stringify(blueprint));
    }
}
/**
 * Create and configure a chain session manager
 */
export function createChainSessionManager(logger, textReferenceManager, serverRoot, options, argumentHistoryTracker) {
    const manager = new ChainSessionManager(logger, textReferenceManager, {
        serverRoot,
        ...options,
    }, argumentHistoryTracker);
    return manager;
}
//# sourceMappingURL=manager.js.map