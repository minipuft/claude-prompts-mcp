import { ValidationError } from '../utils/errorHandling.js';
export class FrameworkValidator {
    constructor(registry, logger, config = {}) {
        this.registry = registry;
        this.logger = logger;
        this.defaultStage = config.defaultStage ?? 'framework_validation';
    }
    /**
     * Validate and normalize an identifier, returning the framework definition.
     * Throws ValidationError when identifier is missing, unknown, or disabled.
     */
    validateAndNormalize(frameworkId, options = {}) {
        const normalizedId = this.tryNormalize(frameworkId);
        if (!normalizedId) {
            throw this.buildMissingFrameworkError(frameworkId, options);
        }
        const definition = this.registry.getFramework(normalizedId);
        if (!definition) {
            throw this.buildMissingFrameworkError(frameworkId, options);
        }
        if (options.requireEnabled && !definition.enabled) {
            throw this.buildDisabledFrameworkError(definition.id, options);
        }
        this.logger.debug('[FrameworkValidator] Framework validated', {
            requestedId: frameworkId,
            normalizedId: definition.id,
            requireEnabled: options.requireEnabled ?? false,
        });
        return {
            normalizedId: definition.id,
            definition,
        };
    }
    /**
     * Return true when the identifier exists in the registry.
     */
    exists(frameworkId, options = {}) {
        const normalizedId = this.tryNormalize(frameworkId);
        if (!normalizedId) {
            return false;
        }
        if (options.enabledOnly) {
            return this.registry.isFrameworkEnabled(normalizedId);
        }
        return Boolean(this.registry.getFramework(normalizedId));
    }
    /**
     * Try to normalize the identifier without raising errors.
     */
    tryNormalize(frameworkId) {
        if (!frameworkId || typeof frameworkId !== 'string') {
            return null;
        }
        const trimmed = frameworkId.trim();
        if (!trimmed) {
            return null;
        }
        const validation = this.registry.validateIdentifier(trimmed);
        if (!validation.valid) {
            return null;
        }
        return validation.normalizedId ?? trimmed.toUpperCase();
    }
    buildMissingFrameworkError(frameworkId, options) {
        const sanitized = frameworkId?.trim() ?? '';
        const availableFrameworks = this.registry.getFrameworkIds(false);
        const availableList = availableFrameworks.length
            ? availableFrameworks.join(', ')
            : 'none registered';
        const message = sanitized
            ? `Framework '@${sanitized}' not found. Available frameworks: ${availableList}. ` +
                `Use system_control({ action: "framework", operation: "list" }) for details.`
            : `Framework identifier is required. Available frameworks: ${availableList}. ` +
                `Use system_control({ action: "framework", operation: "list" }) for details.`;
        return new ValidationError(message, this.buildErrorContext(frameworkId, options));
    }
    buildDisabledFrameworkError(frameworkId, options) {
        const message = `Framework '@${frameworkId}' is currently disabled. ` +
            `Use system_control({ action: "framework", operation: "list" }) to review enabled frameworks or re-enable it before retrying.`;
        const context = this.buildErrorContext(frameworkId, options);
        context.suggestions = [
            'Enable the framework through system_control before executing symbolic framework overrides',
            ...(context.suggestions || []),
        ];
        return new ValidationError(message, context);
    }
    buildErrorContext(frameworkId, options) {
        const availableFrameworks = this.registry.getFrameworkIds(true);
        const defaultSuggestions = [
            'Run system_control({ action: "framework", operation: "list" }) to review available frameworks',
            'Ensure the framework prefix matches the registry entry (e.g., @CAGEERF)',
        ];
        return {
            action: options.stage ?? this.defaultStage,
            userInput: { frameworkId },
            suggestions: options.context?.suggestions ?? defaultSuggestions,
            relatedComponents: ['framework-validator', 'framework-registry'],
            ...options.context,
            details: {
                availableFrameworks,
                ...(options.context?.details ?? {}),
            },
        };
    }
}
//# sourceMappingURL=framework-validator.js.map