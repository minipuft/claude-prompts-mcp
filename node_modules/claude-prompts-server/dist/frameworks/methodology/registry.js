// @lifecycle canonical - Loads methodology guides and tracks their registration state.
/**
 * Methodology Registry
 *
 * Centralized registry for loading and managing methodology guides.
 * Uses YAML-based loading exclusively with fail-fast behavior.
 * All methodologies must be defined in methodologies/<id>/methodology.yaml.
 */
// Data-driven methodology system (YAML-only)
import { createGenericGuide } from './generic-methodology-guide.js';
import { RuntimeMethodologyLoader, } from './runtime-methodology-loader.js';
/**
 * Methodology Registry
 *
 * Manages the loading, registration, and lifecycle of methodology guides.
 * Provides a clean separation between guide management and framework orchestration.
 */
export class MethodologyRegistry {
    constructor(logger, config = {}) {
        this.guides = new Map();
        this.initialized = false;
        this.runtimeLoader = null;
        this.logger = logger;
        this.config = {
            autoLoadBuiltIn: config.autoLoadBuiltIn ?? true,
            customGuides: config.customGuides ?? [],
            validateOnRegistration: config.validateOnRegistration ?? true,
            runtimeLoaderConfig: config.runtimeLoaderConfig,
        };
        // RuntimeMethodologyLoader is mandatory - YAML loading is required
        this.runtimeLoader = new RuntimeMethodologyLoader(this.config.runtimeLoaderConfig);
    }
    /**
     * Initialize the methodology registry
     */
    async initialize() {
        if (this.initialized) {
            this.logger.debug('MethodologyRegistry already initialized');
            return;
        }
        this.logger.info('Initializing MethodologyRegistry...');
        const startTime = performance.now();
        try {
            // Load built-in methodology guides if enabled
            if (this.config.autoLoadBuiltIn) {
                await this.loadBuiltInGuides();
            }
            // Load custom guides if provided
            if (this.config.customGuides && this.config.customGuides.length > 0) {
                await this.loadCustomGuides(this.config.customGuides);
            }
            const loadTime = performance.now() - startTime;
            this.initialized = true;
            this.logger.info(`MethodologyRegistry initialized with ${this.guides.size} guides in ${loadTime.toFixed(1)}ms`);
        }
        catch (error) {
            this.logger.error('Failed to initialize MethodologyRegistry:', error);
            throw error;
        }
    }
    /**
     * Register a methodology guide
     */
    async registerGuide(guide, isBuiltIn = false, source = 'custom') {
        const startTime = performance.now();
        try {
            // Validate guide if required
            if (this.config.validateOnRegistration) {
                const validationResult = this.validateGuide(guide);
                if (!validationResult.valid) {
                    this.logger.warn(`Guide validation failed for ${guide.frameworkId}: ${validationResult.errors.join(', ')}`);
                    return false;
                }
            }
            // Check for existing guide with same ID
            if (this.guides.has(guide.frameworkId)) {
                this.logger.warn(`Guide with ID '${guide.frameworkId}' already registered, replacing...`);
            }
            // Create registry entry
            const entry = {
                guide,
                registeredAt: new Date(),
                isBuiltIn,
                enabled: true,
                source,
                metadata: {
                    loadTime: performance.now() - startTime,
                    validationStatus: this.config.validateOnRegistration ? 'passed' : 'not_validated',
                },
            };
            this.guides.set(guide.frameworkId, entry);
            this.logger.debug(`Registered ${isBuiltIn ? 'built-in' : 'custom'} methodology guide: ${guide.frameworkName} (${guide.frameworkId}) [${source}]`);
            return true;
        }
        catch (error) {
            this.logger.error(`Failed to register methodology guide ${guide.frameworkId}:`, error);
            return false;
        }
    }
    /**
     * Get a methodology guide by ID
     */
    getGuide(guideId) {
        this.ensureInitialized();
        const entry = this.guides.get(guideId.toLowerCase());
        if (entry?.enabled) {
            // Update last used timestamp
            entry.metadata.lastUsed = new Date();
            return entry.guide;
        }
        return undefined;
    }
    /**
     * Get all registered methodology guides
     */
    getAllGuides(enabledOnly = true) {
        this.ensureInitialized();
        const guides = [];
        for (const [_, entry] of this.guides) {
            if (!enabledOnly || entry.enabled) {
                guides.push(entry.guide);
            }
        }
        return guides;
    }
    /**
     * Get guide entries with metadata
     */
    getGuideEntries(enabledOnly = true) {
        this.ensureInitialized();
        const entries = [];
        for (const [_, entry] of this.guides) {
            if (!enabledOnly || entry.enabled) {
                entries.push(entry);
            }
        }
        return entries;
    }
    /**
     * Check if a guide is registered
     */
    hasGuide(guideId) {
        this.ensureInitialized();
        return this.guides.has(guideId.toLowerCase());
    }
    /**
     * Enable or disable a methodology guide
     */
    setGuideEnabled(guideId, enabled) {
        this.ensureInitialized();
        const entry = this.guides.get(guideId.toLowerCase());
        if (entry) {
            entry.enabled = enabled;
            this.logger.info(`Methodology guide '${guideId}' ${enabled ? 'enabled' : 'disabled'}`);
            return true;
        }
        this.logger.warn(`Cannot ${enabled ? 'enable' : 'disable'} guide '${guideId}': not found`);
        return false;
    }
    /**
     * Get registry statistics
     */
    getRegistryStats() {
        this.ensureInitialized();
        const entries = Array.from(this.guides.values());
        const enabledCount = entries.filter((e) => e.enabled).length;
        const builtInCount = entries.filter((e) => e.isBuiltIn).length;
        // Count by source
        const sourceDistribution = {
            'yaml-runtime': 0,
            'custom': 0,
        };
        for (const entry of entries) {
            sourceDistribution[entry.source]++;
        }
        return {
            totalGuides: entries.length,
            enabledGuides: enabledCount,
            builtInGuides: builtInCount,
            customGuides: entries.length - builtInCount,
            sourceDistribution,
            averageLoadTime: entries.reduce((sum, e) => sum + e.metadata.loadTime, 0) / entries.length || 0,
            initialized: this.initialized,
            runtimeLoaderStats: this.runtimeLoader?.getStats() ?? null,
        };
    }
    // Private implementation methods
    /**
     * Load built-in methodology guides
     *
     * YAML loading is mandatory with fail-fast behavior.
     * All methodologies must be defined in methodologies/<id>/methodology.yaml.
     */
    async loadBuiltInGuides() {
        this.logger.debug('Loading built-in methodology guides from YAML...');
        // Required built-in methodology IDs
        const builtInIds = ['cageerf', 'react', '5w1h', 'scamper'];
        // Fail-fast: RuntimeMethodologyLoader is required
        if (!this.runtimeLoader) {
            throw new Error('RuntimeMethodologyLoader required. YAML loading is mandatory.');
        }
        let loadedCount = 0;
        for (const id of builtInIds) {
            const definition = this.runtimeLoader.loadMethodology(id);
            if (!definition) {
                throw new Error(`FATAL: Methodology '${id}' not found. Expected: methodologies/${id}/methodology.yaml`);
            }
            const guide = createGenericGuide(definition);
            const success = await this.registerGuide(guide, true, 'yaml-runtime');
            if (!success) {
                throw new Error(`Failed to register built-in methodology guide: ${id}`);
            }
            loadedCount++;
            this.logger.debug(`Loaded methodology from YAML: ${id}`);
        }
        this.logger.info(`Loaded ${loadedCount} built-in methodology guides from YAML`);
        // Discover and load additional methodologies from YAML
        const discoveredIds = this.runtimeLoader.discoverMethodologies();
        const additionalIds = discoveredIds.filter(id => !builtInIds.includes(id));
        for (const id of additionalIds) {
            try {
                const definition = this.runtimeLoader.loadMethodology(id);
                if (definition) {
                    const guide = createGenericGuide(definition);
                    const success = await this.registerGuide(guide, false, 'yaml-runtime');
                    if (success) {
                        this.logger.info(`Discovered additional methodology from YAML: ${id}`);
                    }
                }
            }
            catch (error) {
                this.logger.warn(`Failed to load discovered methodology '${id}':`, error);
            }
        }
    }
    /**
     * Load custom methodology guides
     */
    async loadCustomGuides(customGuides) {
        this.logger.debug(`Loading ${customGuides.length} custom methodology guides...`);
        for (const guide of customGuides) {
            const success = await this.registerGuide(guide, false);
            if (!success) {
                this.logger.warn(`Failed to register custom guide: ${guide.frameworkName}`);
            }
        }
        this.logger.info(`Loaded ${customGuides.length} custom methodology guides`);
    }
    /**
     * Validate a methodology guide
     */
    validateGuide(guide) {
        const errors = [];
        // Check required properties
        if (!guide.frameworkId || typeof guide.frameworkId !== 'string') {
            errors.push('frameworkId is required and must be a string');
        }
        if (!guide.frameworkName || typeof guide.frameworkName !== 'string') {
            errors.push('frameworkName is required and must be a string');
        }
        if (!guide.methodology || typeof guide.methodology !== 'string') {
            errors.push('methodology is required and must be a string');
        }
        if (!guide.version || typeof guide.version !== 'string') {
            errors.push('version is required and must be a string');
        }
        // Check required methods exist
        const requiredMethods = [
            'guidePromptCreation',
            'guideTemplateProcessing',
            'guideExecutionSteps',
            'enhanceWithMethodology',
            'validateMethodologyCompliance',
            'getSystemPromptGuidance',
        ];
        for (const method of requiredMethods) {
            if (typeof guide[method] !== 'function') {
                errors.push(`Required method '${method}' is missing or not a function`);
            }
        }
        return {
            valid: errors.length === 0,
            errors,
        };
    }
    /**
     * Ensure registry is initialized
     */
    ensureInitialized() {
        if (!this.initialized) {
            throw new Error('MethodologyRegistry not initialized. Call initialize() first.');
        }
    }
    /**
     * Get initialization status
     */
    get isInitialized() {
        return this.initialized;
    }
    /**
     * Expose the runtime loader so other components (e.g., hot reload) can reuse
     * the same cache and directory resolution.
     */
    getRuntimeLoader() {
        if (!this.runtimeLoader) {
            throw new Error('RuntimeMethodologyLoader not initialized');
        }
        return this.runtimeLoader;
    }
}
/**
 * Create and initialize a MethodologyRegistry instance
 */
export async function createMethodologyRegistry(logger, config) {
    const registry = new MethodologyRegistry(logger, config);
    await registry.initialize();
    return registry;
}
//# sourceMappingURL=registry.js.map