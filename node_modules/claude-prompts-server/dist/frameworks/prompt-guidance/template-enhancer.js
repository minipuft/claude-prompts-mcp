// @lifecycle canonical - Enhances templates with methodology-specific guidance blocks.
/**
 * Template Enhancer - Resource-Driven Implementation
 *
 * Enhances user templates by injecting methodology guidance and framework-specific
 * improvements selected by the Semantic Judge.
 *
 * Architecture Shift:
 * - Legacy: Hardcoded TypeScript methods generating strings.
 * - Modern: DYNAMIC injection of Markdown resources loaded by PromptAssetManager.
 */
/**
 * Template Enhancer
 *
 * Applies methodology-specific enhancements to user templates by injecting
 * static resources selected by the Semantic Judge (LLM).
 */
export class TemplateEnhancer {
    constructor(logger, config) {
        this.logger = logger;
        this.config = {
            enableArgumentSuggestions: true,
            enableStructureOptimization: true,
            enableSemanticAwareness: true,
            ...config,
        };
    }
    /**
     * Enhance template by injecting selected resources
     * Resource-Driven Architecture
     */
    async enhanceTemplate(template, prompt, 
    // Legacy args kept for interface compatibility but unused
    _methodologyGuide, _framework, _context, semanticAnalysis, availableResources) {
        const startTime = Date.now();
        let enhancedTemplate = template;
        const injectedResources = [];
        // 1. Apply Semantic Enhancements (Resource Injection)
        if (this.config.enableSemanticAwareness &&
            semanticAnalysis?.executionCharacteristics?.advancedChainFeatures?.selected_resources &&
            availableResources) {
            const selectedIds = semanticAnalysis.executionCharacteristics.advancedChainFeatures
                .selected_resources;
            this.logger.debug(`[TemplateEnhancer] Injecting resources: ${selectedIds.join(', ')}`);
            for (const resourceId of selectedIds) {
                // Fuzzy match: "analytical" or "guidance/analytical"
                const resource = availableResources.find((r) => r.id === resourceId || r.id === `guidance/${resourceId}`);
                if (resource) {
                    // Append the resource content (Methodology Frameworks typically go at the end)
                    enhancedTemplate += `\n\n${resource.userMessageTemplate}`;
                    injectedResources.push(resource.id);
                }
                else {
                    this.logger.warn(`[TemplateEnhancer] Resource not found: ${resourceId}`);
                }
            }
        }
        // 2. Legacy Structure Fallback (Minimal)
        // If no resources selected but structure requested, add basic header
        if (injectedResources.length === 0 &&
            this.config.enableStructureOptimization &&
            !template.startsWith('##')) {
            enhancedTemplate = `## Task Context\n\n${template}`;
        }
        return {
            originalTemplate: template,
            enhancedTemplate,
            validation: {
                score: 100, // Assume resources are high quality
                passed: true,
            },
            metadata: {
                processingTimeMs: Date.now() - startTime,
                enhancementLevel: 'resource-driven',
                injectedResources,
            },
        };
    }
    /**
     * Update enhancer configuration
     */
    updateConfig(config) {
        this.config = { ...this.config, ...config };
    }
}
/**
 * Create and configure a TemplateEnhancer instance
 */
export function createTemplateEnhancer(logger, config) {
    return new TemplateEnhancer(logger, config);
}
//# sourceMappingURL=template-enhancer.js.map